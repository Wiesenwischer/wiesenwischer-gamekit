# 6.8 Unit Tests & Verifikation

**Commit:** `test(phase-6): 6.8 Network Unit Tests`
**Branch:** `test/network-tests`

---

## Ziel

Unit Tests für die Netzwerk-Abstractions und Offline-kompatiblen Komponenten. Integration Tests für den gesamten CSP-Zyklus (Input → Server Sim → Reconciliation) soweit ohne echtes Netzwerk testbar.

---

## Anweisungen

### 1. Tests in Core (FishNet-frei)

Diese Tests gehören in das Core-Package, da sie keine FishNet-Abhängigkeit brauchen:

**Datei:** `CharacterController.Core/Tests/Runtime/Network/NetworkRoleTests.cs`

```csharp
using NUnit.Framework;

namespace Wiesenwischer.GameKit.CharacterController.Core.Tests
{
    [TestFixture]
    public class NetworkRoleTests
    {
        [Test]
        public void OfflineRole_IsOwner_ReturnsTrue()
        {
            Assert.IsTrue(OfflineNetworkRole.Instance.IsOwner);
        }

        [Test]
        public void OfflineRole_IsNetworkActive_ReturnsFalse()
        {
            Assert.IsFalse(OfflineNetworkRole.Instance.IsNetworkActive);
        }

        [Test]
        public void OfflineRole_IsClient_ReturnsTrue()
        {
            Assert.IsTrue(OfflineNetworkRole.Instance.IsClient);
        }

        [Test]
        public void OfflineRole_IsServer_ReturnsFalse()
        {
            Assert.IsFalse(OfflineNetworkRole.Instance.IsServer);
        }

        [Test]
        public void OfflineRole_IsSingleton()
        {
            Assert.AreSame(
                OfflineNetworkRole.Instance,
                OfflineNetworkRole.Instance);
        }
    }
}
```

### 2. InputBuffer Tests (ergänzen)

Falls noch nicht vorhanden, Tests für InputBuffer-Funktionalität die für Network-Sync relevant ist:

**Datei:** `CharacterController.Core/Tests/Runtime/Prediction/InputBufferNetworkTests.cs`

```csharp
using NUnit.Framework;
using System.Linq;

namespace Wiesenwischer.GameKit.CharacterController.Core.Tests
{
    [TestFixture]
    public class InputBufferNetworkTests
    {
        private InputBuffer<ControllerInput> _buffer;

        [SetUp]
        public void SetUp()
        {
            _buffer = new InputBuffer<ControllerInput>(
                capacity: 64,
                tickGetter: input => input.Tick);
        }

        [Test]
        public void GetRange_ReturnsBatchForNetwork()
        {
            // Simuliere Input-Recording über mehrere Ticks
            for (int i = 0; i < 10; i++)
            {
                _buffer.Add(ControllerInput.Create(
                    tick: i,
                    move: UnityEngine.Vector2.up,
                    look: UnityEngine.Vector2.zero,
                    rotation: 0f,
                    buttons: ControllerButtons.None));
            }

            // Batch für Netzwerk: Ticks 3-7
            var batch = _buffer.GetRange(3, 7);
            Assert.AreEqual(5, batch.Count);
            Assert.AreEqual(3, batch.First().Tick);
            Assert.AreEqual(7, batch.Last().Tick);
        }

        [Test]
        public void RemoveBefore_CleansUpAcknowledgedTicks()
        {
            for (int i = 0; i < 10; i++)
            {
                _buffer.Add(ControllerInput.Create(
                    tick: i,
                    move: UnityEngine.Vector2.zero,
                    look: UnityEngine.Vector2.zero,
                    rotation: 0f,
                    buttons: ControllerButtons.None));
            }

            // Server hat Tick 5 bestätigt → alles davor aufräumen
            _buffer.RemoveBefore(5);

            Assert.IsFalse(_buffer.HasTick(4));
            Assert.IsTrue(_buffer.HasTick(5));
            Assert.IsTrue(_buffer.HasTick(9));
        }

        [Test]
        public void ControllerInput_ButtonFlags_WorkCorrectly()
        {
            var input = ControllerInput.Create(
                tick: 1,
                move: UnityEngine.Vector2.zero,
                look: UnityEngine.Vector2.zero,
                rotation: 0f,
                buttons: ControllerButtons.Jump | ControllerButtons.Sprint);

            Assert.IsTrue(input.Jump);
            Assert.IsTrue(input.Sprint);
            Assert.IsFalse(input.Crouch);
            Assert.IsFalse(input.PrimaryAction);
        }
    }
}
```

### 3. PredictionBuffer Reconciliation Tests

**Datei:** `CharacterController.Core/Tests/Runtime/Prediction/ReconciliationTests.cs`

```csharp
using NUnit.Framework;
using UnityEngine;

namespace Wiesenwischer.GameKit.CharacterController.Core.Tests
{
    [TestFixture]
    public class ReconciliationTests
    {
        private PredictionBuffer _buffer;

        [SetUp]
        public void SetUp()
        {
            _buffer = new PredictionBuffer(capacity: 128);
        }

        [Test]
        public void ValidateAgainstServer_ReturnsTrue_WhenMatching()
        {
            var localState = PredictionState.Create(
                tick: 10,
                position: new Vector3(5f, 0f, 5f),
                rotation: 90f,
                velocity: Vector3.forward,
                stateName: "Grounded",
                isGrounded: true);

            _buffer.Add(localState);

            var serverState = PredictionState.Create(
                tick: 10,
                position: new Vector3(5.01f, 0f, 5.01f),  // Minimal offset
                rotation: 90f,
                velocity: Vector3.forward,
                stateName: "Grounded",
                isGrounded: true);

            Assert.IsTrue(_buffer.ValidateAgainstServer(
                serverState, posThreshold: 0.1f));
        }

        [Test]
        public void ValidateAgainstServer_ReturnsFalse_WhenMismatch()
        {
            var localState = PredictionState.Create(
                tick: 10,
                position: new Vector3(5f, 0f, 5f),
                rotation: 90f,
                velocity: Vector3.forward,
                stateName: "Grounded",
                isGrounded: true);

            _buffer.Add(localState);

            var serverState = PredictionState.Create(
                tick: 10,
                position: new Vector3(6f, 0f, 6f),  // Deutlich anders
                rotation: 90f,
                velocity: Vector3.forward,
                stateName: "Grounded",
                isGrounded: true);

            Assert.IsFalse(_buffer.ValidateAgainstServer(
                serverState, posThreshold: 0.1f));
        }

        [Test]
        public void RemoveAfter_ClearsStatesForRollback()
        {
            for (int i = 0; i < 20; i++)
            {
                _buffer.Add(PredictionState.Create(
                    tick: i,
                    position: Vector3.zero,
                    rotation: 0f,
                    velocity: Vector3.zero,
                    stateName: "Grounded",
                    isGrounded: true));
            }

            // Rollback auf Tick 10 → States 11-19 löschen
            _buffer.RemoveAfter(10);

            Assert.IsTrue(_buffer.TryGet(10, out _));
            Assert.IsFalse(_buffer.TryGet(11, out _));
            Assert.IsFalse(_buffer.TryGet(19, out _));
        }

        [Test]
        public void GetFromTick_ReturnsStatesForResimulation()
        {
            for (int i = 0; i < 10; i++)
            {
                _buffer.Add(PredictionState.Create(
                    tick: i,
                    position: Vector3.one * i,
                    rotation: 0f,
                    velocity: Vector3.zero,
                    stateName: "Grounded",
                    isGrounded: true));
            }

            var states = _buffer.GetFromTick(5);
            Assert.AreEqual(5, states.Count); // Ticks 5,6,7,8,9
        }
    }
}
```

### 4. TickSystem Network-Relevante Tests

**Datei:** `CharacterController.Core/Tests/Runtime/Prediction/TickSystemNetworkTests.cs`

```csharp
using NUnit.Framework;

namespace Wiesenwischer.GameKit.CharacterController.Core.Tests
{
    [TestFixture]
    public class TickSystemNetworkTests
    {
        [Test]
        public void SetTick_AllowsRollback()
        {
            var tickSystem = new TickSystem(60f);

            // Simuliere 10 Ticks
            for (int i = 0; i < 10; i++)
                tickSystem.Update(tickSystem.TickDelta);

            Assert.AreEqual(10, tickSystem.CurrentTick);

            // Rollback auf Tick 5
            tickSystem.SetTick(5);
            Assert.AreEqual(5, tickSystem.CurrentTick);
        }

        [Test]
        public void TickDelta_MatchesTick60Hz()
        {
            var tickSystem = new TickSystem(60f);
            Assert.AreEqual(1f / 60f, tickSystem.TickDelta, 0.0001f);
        }

        [Test]
        public void TickToTime_ConvertsCorrectly()
        {
            var tickSystem = new TickSystem(60f);
            float time = tickSystem.TickToTime(60);
            Assert.AreEqual(1f, time, 0.001f); // 60 Ticks bei 60Hz = 1 Sekunde
        }
    }
}
```

### 5. Network-Package Tests (mit FishNet)

Tests im Network.FishNet-Package. Diese testen die Klassen so weit wie möglich ohne echte Netzwerkverbindung:

**Datei:** `Network.FishNet/Tests/Runtime/Core/ControllerInputSerializationTests.cs`

```csharp
using NUnit.Framework;
using UnityEngine;

namespace Wiesenwischer.GameKit.Network.Tests
{
    [TestFixture]
    public class ControllerInputSerializationTests
    {
        [Test]
        public void ControllerInput_Create_SetsAllFields()
        {
            var input = ControllerInput.Create(
                tick: 42,
                move: new Vector2(0.5f, -0.3f),
                look: new Vector2(1f, 0f),
                rotation: 180f,
                buttons: ControllerButtons.Jump | ControllerButtons.Sprint);

            Assert.AreEqual(42, input.Tick);
            Assert.AreEqual(0.5f, input.MoveDirection.x, 0.001f);
            Assert.AreEqual(-0.3f, input.MoveDirection.y, 0.001f);
            Assert.AreEqual(180f, input.Rotation, 0.001f);
            Assert.IsTrue(input.Jump);
            Assert.IsTrue(input.Sprint);
        }

        [Test]
        public void ControllerInput_Empty_HasNoButtons()
        {
            var input = ControllerInput.Empty(0);
            Assert.IsFalse(input.Jump);
            Assert.IsFalse(input.Sprint);
            Assert.IsFalse(input.Crouch);
            Assert.AreEqual(Vector2.zero, input.MoveDirection);
        }

        [Test]
        public void ControllerInput_Equality_WorksCorrectly()
        {
            var a = ControllerInput.Create(1, Vector2.up, Vector2.zero, 0f,
                ControllerButtons.Jump);
            var b = ControllerInput.Create(1, Vector2.up, Vector2.zero, 0f,
                ControllerButtons.Jump);
            var c = ControllerInput.Create(2, Vector2.up, Vector2.zero, 0f,
                ControllerButtons.Jump);

            Assert.AreEqual(a, b);
            Assert.AreNotEqual(a, c);
        }
    }
}
```

### 6. Play Mode Verifikation (mit ParrelSync)

Manuelle Verifikation mit zwei Unity-Editoren via ParrelSync (installiert in 6.1):

**Vorbereitung:**
1. ParrelSync → Clones Manager → Klon muss erstellt sein (siehe 6.1)
2. "Open in New Editor" → zweiter Unity Editor öffnet sich

**Test-Checkliste:**
1. **Editor 1:** `NetworkTestScene` öffnen, Play drücken, "Host" klicken
2. **Editor 2:** `NetworkTestScene` öffnen, Play drücken, "Client" klicken
3. Host bewegt sich → Client sieht Bewegung
4. Client bewegt sich → Host sieht Bewegung
5. Latenz simulieren (Tugboat → Latency Simulation im NetworkManager Inspector)
6. Bei 100ms künstlicher Latenz: Lokale Bewegung bleibt flüssig
7. Bei Packet Loss: Remote-Spieler extrapoliert kurz, dann korrigiert
8. Ohne Netzwerk (kein Host/Client): Offline-Modus funktioniert wie bisher

---

## Verifikation

- [ ] Alle Core Unit Tests grün (NetworkRole, InputBuffer, PredictionBuffer, TickSystem)
- [ ] Network Package Tests grün (Serialization)
- [ ] Play Mode: Host + Client verbinden erfolgreich
- [ ] Play Mode: Gegenseitige Sichtbarkeit und Bewegung
- [ ] Offline-Modus: Keine Regression

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.CharacterController.Core/Tests/Runtime/
├── Network/
│   └── NetworkRoleTests.cs
└── Prediction/
    ├── InputBufferNetworkTests.cs
    ├── ReconciliationTests.cs
    └── TickSystemNetworkTests.cs

Packages/Wiesenwischer.GameKit.Network.FishNet/Tests/Runtime/Core/
└── ControllerInputSerializationTests.cs
```

---

## Hinweise

- FishNet bietet eigene Test-Utilities (`FishNet.Testing`), aber diese erfordern Server/Client in Play Mode
- Die meisten Tests hier sind **Offline-Tests** der Datenstrukturen und Algorithmen
- Echte Netzwerk-Tests (Multi-Client) erfordern ParrelSync oder Builds
- Integration Tests mit echtem Netzwerk können in einer späteren Phase ergänzt werden

---

→ Phase 6 abgeschlossen! Nächste Phase: [Phase 7: Netzwerk-Animation](../phase-7-network-animation/)
