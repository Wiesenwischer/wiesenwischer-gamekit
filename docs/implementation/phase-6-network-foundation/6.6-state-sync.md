# 6.6 State Sync & Reconciliation

**Commit:** `feat(phase-6): 6.6 State Sync & Reconciliation`
**Branch:** `feat/network-state-sync`

---

## Ziel

Server sendet den autoritativen Zustand (`PredictionState`) an alle Clients. Der Owner-Client vergleicht mit seiner lokalen Vorhersage und führt bei Abweichung einen Rollback + Re-Simulation durch. Dies ist die Server→Client-Richtung des CSP-Zyklus.

---

## Anweisungen

### 1. NetworkStateSync Komponente

Neue Klasse in `Network.FishNet/Runtime/Core/NetworkStateSync.cs`:

```csharp
using FishNet.Object;
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core;
using Wiesenwischer.GameKit.CharacterController.Core.Prediction;

namespace Wiesenwischer.GameKit.Network
{
    /// <summary>
    /// Synchronisiert den autoritativen Server-State zu allen Clients.
    /// Owner-Client nutzt den State für Reconciliation (Rollback + Resim).
    /// Non-Owner-Clients nutzen den State für Interpolation.
    /// </summary>
    [RequireComponent(typeof(NetworkPlayer))]
    public class NetworkStateSync : NetworkBehaviour
    {
        [Header("Reconciliation")]
        [Tooltip("Positionsabweichung ab der ein Rollback ausgelöst wird (in Metern)")]
        [SerializeField] private float _positionThreshold = 0.1f;

        [Tooltip("Geschwindigkeitsabweichung ab der ein Rollback ausgelöst wird")]
        [SerializeField] private float _velocityThreshold = 0.5f;

        [Tooltip("Rate in Ticks für State-Broadcasts (z.B. alle 3 Ticks)")]
        [SerializeField] private int _broadcastRate = 3;

        [Header("Snap Correction")]
        [Tooltip("Maximale Distanz für sanfte Korrektur statt Teleport")]
        [SerializeField] private float _snapDistance = 2f;

        [Tooltip("Lerp-Speed für sanfte Position-Korrektur")]
        [SerializeField] private float _correctionSpeed = 10f;

        private PlayerController _player;
        private PredictionBuffer _predictionBuffer;
        private InputBuffer<ControllerInput> _inputBuffer;
        private int _lastBroadcastTick = -1;

        // Korrektur-State
        private bool _hasPendingCorrection;
        private Vector3 _correctionTarget;

        public override void OnStartNetwork()
        {
            base.OnStartNetwork();
            _player = GetComponent<PlayerController>();

            _predictionBuffer = new PredictionBuffer(capacity: 256);
            _inputBuffer = new InputBuffer<ControllerInput>(
                capacity: 256,
                tickGetter: input => input.Tick);
        }

        private void Update()
        {
            if (IsOwner)
            {
                // Owner: State aufzeichnen für spätere Reconciliation
                RecordPredictionState();

                // Sanfte Korrektur anwenden (falls Reconciliation aktiv)
                if (_hasPendingCorrection)
                    ApplySmoothCorrection();
            }
        }

        // === Server-Seite ===

        /// <summary>
        /// Vom Server aufgerufen nach jeder Simulation.
        /// Broadcastet den autoritativen State an alle Clients.
        /// </summary>
        [Server]
        public void BroadcastState(int tick, PredictionState state)
        {
            if (tick - _lastBroadcastTick < _broadcastRate) return;

            ObserverRpcReceiveState(state);
            _lastBroadcastTick = tick;
        }

        // === Client-Seite ===

        /// <summary>
        /// Alle Clients empfangen den Server-State.
        /// Owner → Reconciliation. Non-Owner → Interpolation Buffer.
        /// </summary>
        [ObserverRpc(BufferLast = true)]
        private void ObserverRpcReceiveState(PredictionState serverState)
        {
            if (IsOwner)
                HandleReconciliation(serverState);
            else
                HandleRemoteState(serverState);
        }

        private void HandleReconciliation(PredictionState serverState)
        {
            // Vergleiche Server-State mit lokaler Vorhersage
            if (!_predictionBuffer.TryGet(serverState.Tick, out var localState))
            {
                // Kein lokaler State für diesen Tick → Hard Snap
                ApplyHardCorrection(serverState);
                return;
            }

            bool positionMismatch =
                Vector3.Distance(localState.Position, serverState.Position) > _positionThreshold;
            bool velocityMismatch =
                Vector3.Distance(localState.Velocity, serverState.Velocity) > _velocityThreshold;

            if (!positionMismatch && !velocityMismatch)
            {
                // Vorhersage war korrekt → alten State aufräumen
                _predictionBuffer.RemoveBefore(serverState.Tick);
                _inputBuffer.RemoveBefore(serverState.Tick);
                return;
            }

            // Mismatch! → Rollback + Re-Simulation
            PerformRollback(serverState);
        }

        private void PerformRollback(PredictionState serverState)
        {
            Debug.Log($"[Reconciliation] Rollback von Tick {serverState.Tick}" +
                      $" (Δpos={Vector3.Distance(_player.transform.position, serverState.Position):F3}m)");

            // 1. State auf Server-Wert setzen
            _player.SetPosition(serverState.Position);
            // Rotation und Velocity ebenfalls setzen
            // (erfordert ggf. Erweiterung von PlayerController)

            // 2. Alte States nach dem Server-Tick löschen
            _predictionBuffer.RemoveAfter(serverState.Tick);

            // 3. Re-Simulation: Alle Inputs seit dem Server-Tick erneut anwenden
            int currentTick = _player.CurrentTick;
            var pendingInputs = _inputBuffer.GetRange(serverState.Tick + 1, currentTick);
            float tickDelta = _player.TickSystem.TickDelta;

            foreach (var input in pendingInputs)
            {
                _player.ApplyNetworkInput(input, tickDelta);

                // Neuen State aufzeichnen
                var newState = CreateStateSnapshot(input.Tick);
                _predictionBuffer.Add(newState);
            }

            // 4. Sanfte visuelle Korrektur statt hartem Snap
            float distance = Vector3.Distance(
                _player.transform.position, serverState.Position);
            if (distance < _snapDistance)
            {
                _hasPendingCorrection = true;
                _correctionTarget = _player.transform.position;
            }
        }

        private void ApplyHardCorrection(PredictionState serverState)
        {
            _player.SetPosition(serverState.Position);
            _predictionBuffer.RemoveAfter(0);
        }

        private void ApplySmoothCorrection()
        {
            float step = _correctionSpeed * Time.deltaTime;
            _player.transform.position = Vector3.MoveTowards(
                _player.transform.position, _correctionTarget, step);

            if (Vector3.Distance(_player.transform.position, _correctionTarget) < 0.001f)
                _hasPendingCorrection = false;
        }

        private void HandleRemoteState(PredictionState serverState)
        {
            // Für Remote-Spieler: State im Buffer speichern
            // → RemotePlayerInterpolator (6.7) liest daraus
            _predictionBuffer.Add(serverState);
        }

        // === Hilfsmethoden ===

        private void RecordPredictionState()
        {
            var state = CreateStateSnapshot(_player.CurrentTick);
            _predictionBuffer.Add(state);
        }

        private PredictionState CreateStateSnapshot(int tick)
        {
            return PredictionState.Create(
                tick: tick,
                position: _player.transform.position,
                rotation: _player.transform.eulerAngles.y,
                velocity: _player.Velocity,
                stateName: _player.MovementStateMachine?.CurrentStateName ?? "Unknown",
                isGrounded: _player.IsGrounded
            );
        }
    }
}
```

### 2. Server-Simulation integrieren

Die Server-Simulation (aus 6.5 `SimulateOnServer()`) muss den State nach jeder Simulation an `NetworkStateSync.BroadcastState()` weiterleiten:

```csharp
// In NetworkInputSync.SimulateOnServer():
private void SimulateOnServer(ControllerInput input)
{
    float tickDelta = _player.TickSystem.TickDelta;
    _player.ApplyNetworkInput(input, tickDelta);

    // State an alle Clients broadcasten
    var stateSync = GetComponent<NetworkStateSync>();
    var state = PredictionState.Create(
        tick: input.Tick,
        position: _player.transform.position,
        rotation: _player.transform.eulerAngles.y,
        velocity: _player.Velocity,
        stateName: _player.MovementStateMachine?.CurrentStateName ?? "Unknown",
        isGrounded: _player.IsGrounded
    );
    stateSync.BroadcastState(input.Tick, state);
}
```

### 3. PredictionState Serialisierung

Analog zu `ControllerInput` — FishNet Custom Serializer falls nötig:

```csharp
using FishNet.Serializing;

namespace Wiesenwischer.GameKit.Network
{
    public static class PredictionStateSerializer
    {
        public static void WritePredictionState(
            this Writer writer, PredictionState value)
        {
            writer.WriteInt32(value.Tick);
            writer.WriteVector3(value.Position);
            writer.WriteSingle(value.Rotation);
            writer.WriteVector3(value.Velocity);
            writer.WriteString(value.StateName);
            writer.WriteBoolean(value.IsGrounded);
            writer.WriteSingle(value.Timestamp);
        }

        public static PredictionState ReadPredictionState(this Reader reader)
        {
            return PredictionState.Create(
                tick: reader.ReadInt32(),
                position: reader.ReadVector3(),
                rotation: reader.ReadSingle(),
                velocity: reader.ReadVector3(),
                stateName: reader.ReadString(),
                isGrounded: reader.ReadBoolean()
            );
        }
    }
}
```

---

## Verifikation

- [ ] Server broadcastet State periodisch (alle 3 Ticks)
- [ ] Owner-Client empfängt State und vergleicht mit PredictionBuffer
- [ ] Ohne Abweichung: Kein Rollback (stilles Aufräumen des Buffers)
- [ ] Mit Abweichung: Rollback + Re-Sim (Debug.Log zeigt Tick und Distanz)
- [ ] Sanfte Korrektur statt hartem Teleport bei kleinen Abweichungen
- [ ] Non-Owner-Clients empfangen State für Interpolation (6.7)

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.Network.FishNet/Runtime/Core/
├── NetworkStateSync.cs
└── PredictionStateSerializer.cs    (optional)
```

Geänderte Dateien:
- `NetworkInputSync.cs` — `SimulateOnServer()` ruft `BroadcastState()` auf

---

## Hinweise

- **Broadcast Rate:** Alle 3 Ticks (= 20 Hz bei 60 Hz Tick Rate) ist ein guter Kompromiss zwischen Bandbreite und Genauigkeit
- **Rollback + Re-Sim** ist CPU-intensiv aber selten nötig (nur bei echten Abweichungen)
- **BufferLast = true:** FishNet sendet den letzten State automatisch an neue Clients
- Bei hoher Latenz (>150ms) können mehr Rollbacks auftreten — `_positionThreshold` erhöhen um unnötige Rollbacks zu vermeiden

---

→ Nächster Schritt: [6.7 Remote Player Interpolation](6.7-remote-interpolation.md)
