# 6.7 Remote Player Interpolation

**Commit:** `feat(phase-6): 6.7 Remote Player Interpolation`
**Branch:** `feat/remote-interpolation`

---

## Ziel

Remote-Spieler (nicht-lokale) werden zwischen Server-State-Updates interpoliert, damit die Bewegung flüssig aussieht. Ohne Interpolation würden Remote-Spieler bei jedem State-Update "springen" (20 Hz statt 60 FPS).

---

## Anweisungen

### 1. RemotePlayerInterpolator Komponente

Neue Klasse in `Network.FishNet/Runtime/Core/RemotePlayerInterpolator.cs`:

```csharp
using System.Collections.Generic;
using FishNet.Object;
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core.Prediction;

namespace Wiesenwischer.GameKit.Network
{
    /// <summary>
    /// Interpoliert Position und Rotation für Remote-Spieler
    /// basierend auf gepufferten Server-States.
    /// Verwendet Entity Interpolation mit konfigurierbarem Delay.
    /// </summary>
    [RequireComponent(typeof(NetworkPlayer))]
    public class RemotePlayerInterpolator : NetworkBehaviour
    {
        [Header("Interpolation")]
        [Tooltip("Interpolations-Delay in Sekunden (Buffer für Jitter)")]
        [SerializeField] private float _interpolationDelay = 0.1f;

        [Tooltip("Extrapolations-Limit wenn keine neuen States ankommen")]
        [SerializeField] private float _maxExtrapolationTime = 0.25f;

        [Header("Smoothing")]
        [Tooltip("Teleport-Schwelle — über dieser Distanz wird direkt gesprungen")]
        [SerializeField] private float _teleportThreshold = 5f;

        // State Buffer (chronologisch sortiert)
        private readonly List<TimedState> _stateBuffer = new();
        private float _lastReceiveTime;
        private bool _isExtrapolating;

        private struct TimedState
        {
            public float Time;
            public Vector3 Position;
            public float Rotation;
            public Vector3 Velocity;
            public bool IsGrounded;
        }

        /// <summary>
        /// Wird von NetworkStateSync aufgerufen wenn ein neuer
        /// Server-State für diesen Remote-Spieler eintrifft.
        /// </summary>
        public void OnRemoteStateReceived(PredictionState state)
        {
            float receiveTime = Time.time;
            _lastReceiveTime = receiveTime;
            _isExtrapolating = false;

            _stateBuffer.Add(new TimedState
            {
                Time = receiveTime,
                Position = state.Position,
                Rotation = state.Rotation,
                Velocity = state.Velocity,
                IsGrounded = state.IsGrounded
            });

            // Buffer aufräumen — maximal 1 Sekunde History
            while (_stateBuffer.Count > 0 &&
                   _stateBuffer[0].Time < receiveTime - 1f)
            {
                _stateBuffer.RemoveAt(0);
            }
        }

        private void Update()
        {
            // Nur für Remote-Spieler (nicht-Owner)
            if (IsOwner) return;
            if (_stateBuffer.Count < 2) return;

            float renderTime = Time.time - _interpolationDelay;

            // Zwei States finden, zwischen denen interpoliert wird
            if (TryFindInterpolationStates(renderTime,
                out var from, out var to, out float t))
            {
                ApplyInterpolation(from, to, t);
            }
            else if (Time.time - _lastReceiveTime < _maxExtrapolationTime)
            {
                // Kein passender State → Extrapolation
                Extrapolate();
            }
            // Sonst: Spieler bleibt stehen (kein State)
        }

        private bool TryFindInterpolationStates(float targetTime,
            out TimedState from, out TimedState to, out float t)
        {
            from = default;
            to = default;
            t = 0f;

            for (int i = 0; i < _stateBuffer.Count - 1; i++)
            {
                if (_stateBuffer[i].Time <= targetTime &&
                    _stateBuffer[i + 1].Time >= targetTime)
                {
                    from = _stateBuffer[i];
                    to = _stateBuffer[i + 1];
                    float duration = to.Time - from.Time;
                    t = duration > 0 ? (targetTime - from.Time) / duration : 0f;
                    return true;
                }
            }

            return false;
        }

        private void ApplyInterpolation(TimedState from, TimedState to, float t)
        {
            Vector3 targetPos = Vector3.Lerp(from.Position, to.Position, t);
            float targetRot = Mathf.LerpAngle(from.Rotation, to.Rotation, t);

            // Teleport-Check
            float distance = Vector3.Distance(transform.position, targetPos);
            if (distance > _teleportThreshold)
            {
                transform.position = targetPos;
            }
            else
            {
                transform.position = targetPos;
            }

            transform.rotation = Quaternion.Euler(0, targetRot, 0);
        }

        private void Extrapolate()
        {
            if (_stateBuffer.Count == 0) return;

            var lastState = _stateBuffer[^1];
            float timeSinceLastState = Time.time - lastState.Time;

            // Einfache lineare Extrapolation basierend auf letzter Velocity
            Vector3 extrapolatedPos =
                lastState.Position + lastState.Velocity * timeSinceLastState;

            transform.position = extrapolatedPos;
            _isExtrapolating = true;
        }

        /// <summary>Buffer leeren (z.B. bei Respawn).</summary>
        public void ClearBuffer()
        {
            _stateBuffer.Clear();
            _isExtrapolating = false;
        }
    }
}
```

### 2. NetworkStateSync Integration

In `NetworkStateSync.HandleRemoteState()` den Interpolator füttern:

```csharp
// In NetworkStateSync:
private RemotePlayerInterpolator _interpolator;

public override void OnStartNetwork()
{
    // ... existing code ...
    _interpolator = GetComponent<RemotePlayerInterpolator>();
}

private void HandleRemoteState(PredictionState serverState)
{
    _predictionBuffer.Add(serverState);

    // Interpolator mit neuem State füttern
    if (_interpolator != null)
        _interpolator.OnRemoteStateReceived(serverState);
}
```

### 3. Remote Player — PlayerController deaktivieren

Für Remote-Spieler soll der `PlayerController.Update()` nicht laufen (kein lokales Physik-Update):

```csharp
// In NetworkPlayer.DisableRemotePlayerInput():
private void DisableRemotePlayerInput()
{
    // Input deaktivieren
    var inputProvider = GetComponent<IMovementInputProvider>();
    if (inputProvider is MonoBehaviour inputMono)
        inputMono.enabled = false;

    // PlayerController Update deaktivieren (Interpolator übernimmt Position)
    // NetworkRole.IsOwner == false → PlayerController.Update() macht bereits nichts

    // CharacterMotor deaktivieren (keine lokale Physik für Remote)
    var motor = GetComponent<CharacterMotor>();
    if (motor != null)
        motor.enabled = false;

    Debug.Log("[NetworkPlayer] Remote Spieler — Input + Motor deaktiviert.");
}
```

### 4. Player Prefab aktualisieren

Dem Player Prefab die Komponente `RemotePlayerInterpolator` hinzufügen:

```
Player (Root)
├── NetworkObject
├── NetworkPlayer
├── NetworkInputSync           ← NEU (6.5)
├── NetworkStateSync           ← NEU (6.6)
├── RemotePlayerInterpolator   ← NEU (6.7)
├── PlayerController
├── CharacterMotor
└── ...
```

---

## Verifikation

- [ ] Host startet → lokaler Player bewegt sich mit CSP
- [ ] Client verbindet → sieht den Host-Player sich flüssig bewegen
- [ ] Remote-Spieler "gleiten" sanft (kein Ruckeln/Springen)
- [ ] Bei Packet Loss: Kurze Extrapolation, dann Snap auf neuen State
- [ ] Teleport-Schwelle greift bei großen Distanzen (>5m)
- [ ] Kein Input-Processing auf Remote-Spielern

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.Network.FishNet/Runtime/Core/
└── RemotePlayerInterpolator.cs
```

Geänderte Dateien:
- `NetworkStateSync.cs` — Interpolator-Integration
- `NetworkPlayer.cs` — Motor-Deaktivierung für Remote

---

## Hinweise

- **Interpolation Delay** (100ms) verursacht eine kleine visuelle Verzögerung bei Remote-Spielern, sorgt aber für flüssige Bewegung
- Bei 20 Hz State-Updates und 100ms Delay hat der Interpolator immer mindestens 2 States im Buffer
- **Extrapolation** ist ein Fallback — bei konstantem Netzwerk wird sie selten gebraucht
- Animation-Sync fehlt noch (Phase 7) — Remote-Spieler bewegen sich, aber die Animation passt noch nicht

---

→ Nächster Schritt: [6.8 Unit Tests & Verifikation](6.8-unit-tests.md)
