# 6.5 Input Sync (Client → Server)

**Commit:** `feat(phase-6): 6.5 Input Sync`
**Branch:** `feat/network-input-sync`

---

## Ziel

Client-Input über das Netzwerk an den Server senden. Der Server empfängt `ControllerInput`-Pakete, validiert sie und simuliert die Bewegung autoritativ. Dies ist die Client→Server-Richtung des CSP-Zyklus.

---

## Anweisungen

### 1. NetworkInputSync Komponente

Neue Klasse in `Network.FishNet/Runtime/Core/NetworkInputSync.cs`:

```csharp
using FishNet.Object;
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core;
using Wiesenwischer.GameKit.CharacterController.Core.Prediction;

namespace Wiesenwischer.GameKit.Network
{
    /// <summary>
    /// Synchronisiert Client-Input zum Server.
    /// Owner-Client sammelt ControllerInput pro Tick und sendet Batches.
    /// Server empfängt, validiert und simuliert.
    /// </summary>
    [RequireComponent(typeof(NetworkPlayer))]
    public class NetworkInputSync : NetworkBehaviour
    {
        [Header("Settings")]
        [SerializeField] private int _batchSize = 3;
        [SerializeField] private float _maxMoveInputMagnitude = 1.1f;

        private PlayerController _player;
        private InputBuffer<ControllerInput> _inputBuffer;
        private int _lastSentTick = -1;

        public override void OnStartNetwork()
        {
            base.OnStartNetwork();
            _player = GetComponent<PlayerController>();
            _inputBuffer = new InputBuffer<ControllerInput>(
                capacity: 128,
                tickGetter: input => input.Tick);
        }

        private void Update()
        {
            if (!IsOwner) return;

            // Input im Buffer aufzeichnen
            RecordCurrentInput();

            // Periodisch Input-Batch an Server senden
            if (ShouldSendBatch())
                SendInputBatch();
        }

        private void RecordCurrentInput()
        {
            var input = CreateControllerInput();
            _inputBuffer.Add(input);
        }

        private ControllerInput CreateControllerInput()
        {
            // Baut ControllerInput aus PlayerController-State
            var buttons = ControllerButtons.None;
            var inputProvider = _player.InputProvider;

            if (inputProvider.JumpPressed) buttons |= ControllerButtons.Jump;
            if (inputProvider.SprintHeld) buttons |= ControllerButtons.Sprint;
            if (inputProvider.CrouchTogglePressed) buttons |= ControllerButtons.Crouch;

            return ControllerInput.Create(
                tick: _player.CurrentTick,
                move: inputProvider.MoveInput,
                look: inputProvider.LookInput,
                rotation: _player.transform.eulerAngles.y,
                buttons: buttons
            );
        }

        private bool ShouldSendBatch()
        {
            return _player.CurrentTick - _lastSentTick >= _batchSize;
        }

        private void SendInputBatch()
        {
            int fromTick = _lastSentTick + 1;
            int toTick = _player.CurrentTick;
            var inputs = _inputBuffer.GetRange(fromTick, toTick);

            if (inputs.Count == 0) return;

            ServerRpcReceiveInput(inputs.ToArray());
            _lastSentTick = toTick;
        }

        /// <summary>
        /// Server empfängt Input-Batch vom Client.
        /// Validiert und simuliert jeden Input.
        /// </summary>
        [ServerRpc]
        private void ServerRpcReceiveInput(ControllerInput[] inputs)
        {
            foreach (var input in inputs)
            {
                if (!ValidateInput(input))
                {
                    Debug.LogWarning(
                        $"[NetworkInputSync] Ungültiger Input von " +
                        $"Client {OwnerId} bei Tick {input.Tick}");
                    continue;
                }

                // Server simuliert die Bewegung mit dem empfangenen Input
                SimulateOnServer(input);
            }
        }

        private bool ValidateInput(ControllerInput input)
        {
            // Basis-Validierung
            if (input.MoveDirection.magnitude > _maxMoveInputMagnitude)
                return false;

            // Tick muss fortlaufend sein (keine Duplikate, keine Zeitreisen)
            // Erweiterte Validierung kann hier ergänzt werden

            return true;
        }

        private void SimulateOnServer(ControllerInput input)
        {
            // Server wendet den Input auf PlayerController an
            // und erzeugt den autoritativen State
            // → Wird von NetworkStateSync (6.6) gelesen und broadcastet
        }
    }
}
```

### 2. ControllerInput Serialisierung

FishNet serialisiert Structs automatisch wenn sie `ISerializable` implementieren oder simple Typen enthalten. `ControllerInput` enthält nur primitive Typen und Vector2 → FishNet kann dies nativ serialisieren.

**Falls nötig**, einen Custom Serializer erstellen:

```csharp
using FishNet.Serializing;

namespace Wiesenwischer.GameKit.Network
{
    public static class ControllerInputSerializer
    {
        public static void WriteControllerInput(
            this Writer writer, ControllerInput value)
        {
            writer.WriteInt32(value.Tick);
            writer.WriteVector2(value.MoveDirection);
            writer.WriteVector2(value.LookDirection);
            writer.WriteSingle(value.Rotation);
            writer.WriteUInt16((ushort)value.Buttons);
            writer.WriteSingle(value.Timestamp);
        }

        public static ControllerInput ReadControllerInput(this Reader reader)
        {
            return ControllerInput.Create(
                tick: reader.ReadInt32(),
                move: reader.ReadVector2(),
                look: reader.ReadVector2(),
                rotation: reader.ReadSingle(),
                buttons: (ControllerButtons)reader.ReadUInt16()
            );
        }
    }
}
```

### 3. PlayerController.InputProvider öffentlich machen

Falls `InputProvider` nicht bereits public ist, muss es für `NetworkInputSync` zugänglich sein:

```csharp
// In PlayerController:
public IMovementInputProvider InputProvider => _inputProvider;
```

### 4. Server-seitige Simulation (Grundgerüst)

Der Server muss den empfangenen Input anwenden können. Dafür braucht `PlayerController` eine Methode:

```csharp
// In PlayerController:
/// <summary>
/// Wendet einen ControllerInput an und simuliert einen Tick.
/// Wird vom Server aufgerufen (über NetworkInputSync).
/// </summary>
public void ApplyNetworkInput(ControllerInput input, float tickDelta)
{
    // Input-Werte setzen
    _reusableData.MoveInput = input.MoveDirection;
    _reusableData.JumpPressed = input.Jump;
    _reusableData.SprintHeld = input.Sprint;
    _reusableData.CrouchTogglePressed = input.Crouch;

    // Einen Tick simulieren
    _movementStateMachine?.Update();
    ConsumeMovementEvents();
    ApplyMovement(tickDelta);
}
```

---

## Verifikation

- [ ] Owner-Client sendet Input-Batches an Server (Debug.Log prüfen)
- [ ] Server empfängt und validiert Input (Debug.Log prüfen)
- [ ] Ungültige Inputs (zu große MoveDirection) werden abgelehnt
- [ ] Input-Verlust durch Batching minimiert (Batch enthält mehrere Ticks)
- [ ] Offline-Modus: Kein Einfluss (NetworkInputSync ist nur mit NetworkPlayer aktiv)

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.Network.FishNet/Runtime/Core/
├── NetworkInputSync.cs
└── ControllerInputSerializer.cs     (optional, nur falls FishNet Auto-Serialisierung nicht greift)
```

Geänderte Dateien:
- `PlayerController.cs` — `InputProvider` Property, `ApplyNetworkInput()` Methode

---

## Hinweise

- FishNet `[ServerRpc]` sendet vom Owner-Client zum Server
- Batching (3 Inputs pro Paket) reduziert Netzwerk-Overhead bei 60-Hz-Ticks
- Bei Packet Loss: Server hat die letzten Inputs noch im Buffer (redundante Übertragung möglich durch Overlap)
- Validierung ist zunächst minimal — erweiterte Cheat-Detection (Speed Hacks, Teleport) kann später ergänzt werden

---

→ Nächster Schritt: [6.6 State Sync & Reconciliation](6.6-state-sync.md)
