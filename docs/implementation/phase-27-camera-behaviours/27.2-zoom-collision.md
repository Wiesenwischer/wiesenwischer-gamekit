# 27.2 ZoomBehaviour + CollisionBehaviour

> **Commit:** `feat(phase-27): 27.2 ZoomBehaviour + CollisionBehaviour`

---

## Ziel

Zwei Behaviours extrahieren:
- **ZoomBehaviour** — Distance-Steuerung aus Zoom-Input mit SmoothDamp
- **CollisionBehaviour** — SphereCast-basierte Hindernisvermeidung

---

## 1. ZoomBehaviour

**`Runtime/ZoomBehaviour.cs`**

Extrahiert `CameraBrain.UpdateZoom()`.

```csharp
namespace Wiesenwischer.GameKit.Camera.Behaviours
{
    /// <summary>
    /// Zoom-Verhalten: Steuert Distance basierend auf Zoom-Input.
    /// </summary>
    public class ZoomBehaviour : MonoBehaviour, ICameraBehaviour
    {
        [Header("Distance")]
        [SerializeField] private float _defaultDistance = 5f;
        [SerializeField] private float _minDistance = 2f;
        [SerializeField] private float _maxDistance = 15f;

        [Header("Smoothing")]
        [SerializeField] private float _zoomDamping = 0.1f;

        private float _zoomVelocity;

        public bool IsActive => enabled;

        /// <summary>Initialisiert Distance auf Default-Wert.</summary>
        public void Initialize(ref CameraState state)
        {
            state.Distance = _defaultDistance;
        }

        public void UpdateState(ref CameraState state, CameraContext ctx)
        {
            float targetDistance = state.Distance - ctx.Input.Zoom;
            targetDistance = Mathf.Clamp(targetDistance, _minDistance, _maxDistance);

            state.Distance = Mathf.SmoothDamp(
                state.Distance, targetDistance, ref _zoomVelocity,
                _zoomDamping, Mathf.Infinity, ctx.DeltaTime);
        }
    }
}
```

---

## 2. CollisionBehaviour

**`Runtime/CollisionBehaviour.cs`**

Extrahiert `CameraBrain.CheckCollision()`. Wird **nach** ZoomBehaviour evaluiert und clampt die Distance nach unten.

```csharp
namespace Wiesenwischer.GameKit.Camera.Behaviours
{
    /// <summary>
    /// Collision-Verhalten: Verhindert Camera-Clipping durch SphereCast.
    /// Muss nach ZoomBehaviour in der Behaviour-Liste stehen.
    /// </summary>
    public class CollisionBehaviour : MonoBehaviour, ICameraBehaviour
    {
        [Header("Collision")]
        [SerializeField] private float _collisionRadius = 0.3f;
        [SerializeField] private LayerMask _collisionLayers = ~0;

        [Header("Recovery")]
        [Tooltip("Wie schnell die Kamera nach Kollision zurückgeht (0 = sofort).")]
        [SerializeField] private float _recoverySpeed = 5f;

        private float _currentCollisionDistance;

        public bool IsActive => enabled;

        public void UpdateState(ref CameraState state, CameraContext ctx)
        {
            float desiredDistance = state.Distance;
            float hitDistance = CastForCollision(ctx.AnchorPosition, state, ctx);

            // Snap-In (sofort näher), Recovery (sanft zurück)
            if (hitDistance < desiredDistance)
            {
                _currentCollisionDistance = hitDistance;
            }
            else if (_recoverySpeed > 0f)
            {
                _currentCollisionDistance = Mathf.MoveTowards(
                    _currentCollisionDistance, desiredDistance,
                    _recoverySpeed * ctx.DeltaTime);
            }
            else
            {
                _currentCollisionDistance = desiredDistance;
            }

            state.Distance = Mathf.Min(state.Distance, _currentCollisionDistance);
        }

        private float CastForCollision(Vector3 origin, CameraState state, CameraContext ctx)
        {
            // Berechne Kamera-Zielposition aus State
            Quaternion yawRot = Quaternion.Euler(0f, state.Yaw, 0f);
            Quaternion pitchRot = Quaternion.Euler(state.Pitch, 0f, 0f);
            Vector3 direction = yawRot * pitchRot * Vector3.back;

            float maxDistance = state.Distance;

            if (Physics.SphereCast(origin, _collisionRadius, direction,
                out RaycastHit hit, maxDistance, _collisionLayers,
                QueryTriggerInteraction.Ignore))
            {
                return Mathf.Max(0f, hit.distance - _collisionRadius);
            }

            return maxDistance;
        }
    }
}
```

**Unterschied zum CameraBrain-Embedded:**
- CollisionBehaviour berechnet die Richtung selbst aus CameraState (statt aus PivotRig-Transform)
- Recovery-Speed konfigurierbar (Snap-In sofort, Recovery sanft)
- LayerMask konfigurierbar (statt `Physics.DefaultRaycastLayers`)

---

## Akzeptanzkriterien

- [ ] ZoomBehaviour: Distance ändert sich mit Zoom-Input
- [ ] ZoomBehaviour: Distance wird auf Min/Max geclampt
- [ ] ZoomBehaviour: SmoothDamp für sanften Zoom
- [ ] CollisionBehaviour: SphereCast erkennt Hindernisse
- [ ] CollisionBehaviour: Snap-In ist sofort, Recovery ist konfigurierbar
- [ ] CollisionBehaviour: LayerMask wird berücksichtigt
