# 22.4 PlayerRollingState implementieren

> **Commit:** `feat(phase-22): 22.4 PlayerRollingState implementieren`
> **Branch:** `feat/rolling-state`

---

## Ziel

Neuen `PlayerRollingState` erstellen, der von `PlayerGroundedState` erbt und die Roll-Mechanik implementiert: konstante Geschwindigkeit, sofortige Rotation in Input-Richtung, Jump-Blocking und Animation-basierte Recovery.

## Anweisungen

### 1. PlayerRollingState erstellen

**Datei:** `Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/States/Grounded/PlayerRollingState.cs`

```csharp
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core.Animation;

namespace Wiesenwischer.GameKit.CharacterController.Core.StateMachine.States
{
    /// <summary>
    /// Landing Roll State — Character rollt bei hartem Aufprall mit Movement-Input.
    /// Erbt von PlayerGroundedState für Bodenkontakt-Logik.
    /// Blockiert Jump-Input und deaktiviert Sprint während der Roll.
    /// </summary>
    public class PlayerRollingState : PlayerGroundedState
    {
        public override string StateName => "Rolling";

        private bool _useAnimationBasedRecovery;
        private float _fallbackTimer;
        private const float FallbackDuration = 0.7f;
        private Vector3 _rollDirection;

        public PlayerRollingState(PlayerMovementStateMachine stateMachine) : base(stateMachine)
        {
        }

        protected override void OnEnter()
        {
            base.OnEnter();

            _useAnimationBasedRecovery = Player.AnimationController != null;

            // Roll-Richtung aus kamerarelativem Movement-Input
            _rollDirection = GetCameraRelativeDirection();
            if (_rollDirection == Vector3.zero)
                _rollDirection = Player.transform.forward;

            // Sofortige Rotation in Roll-Richtung (kein SmoothDamp)
            Player.transform.rotation = Quaternion.LookRotation(_rollDirection);

            // Geschwindigkeit setzen: RunSpeed × RollSpeedModifier
            ReusableData.MovementSpeedModifier = Config.RollSpeedModifier;

            // Sprint während Roll deaktivieren
            ReusableData.ShouldSprint = false;

            // Animation starten
            if (_useAnimationBasedRecovery)
            {
                Player.AnimationController.PlayState(CharacterAnimationState.Roll);
            }
            else
            {
                _fallbackTimer = FallbackDuration;
            }
        }

        protected override void OnUpdate()
        {
            // NICHT base.OnUpdate() aufrufen — kein Coyote Time Check,
            // kein Sliding-Check während Roll

            bool recoveryComplete;

            if (_useAnimationBasedRecovery)
            {
                var anim = Player.AnimationController;
                recoveryComplete = anim.CanExitAnimation || anim.IsAnimationComplete();
            }
            else
            {
                _fallbackTimer -= Time.deltaTime;
                recoveryComplete = _fallbackTimer <= 0f;
            }

            if (!recoveryComplete) return;

            // Transition basierend auf aktuellem Input
            if (HasMovementInput())
            {
                if (ReusableData.SprintHeld)
                    ChangeState(stateMachine.SprintingState);
                else if (ReusableData.ShouldWalk)
                    ChangeState(stateMachine.WalkingState);
                else
                    ChangeState(stateMachine.RunningState);
            }
            else
            {
                ChangeState(stateMachine.MediumStoppingState);
            }
        }

        protected override void OnPhysicsUpdate(float deltaTime)
        {
            // Konstante Bewegung in Roll-Richtung (kein Beschleunigen/Abbremsen)
            // Die Geschwindigkeit wird über MovementSpeedModifier × RunSpeed gesteuert
            // und vom Locomotion-System angewendet.
            base.OnPhysicsUpdate(deltaTime);
        }

        protected override void OnExit()
        {
            base.OnExit();
            ReusableData.MovementSpeedModifier = 1f;
        }

        // === Blockierte Inputs ===

        /// <summary>
        /// Jump ist während Roll blockiert — verhindert Jump-Cancel.
        /// </summary>
        protected override void OnJump()
        {
            // Absichtlich leer: Jump-Input wird ignoriert
        }

        // === Hilfsmethoden ===

        /// <summary>
        /// Berechnet die kamerarelative Bewegungsrichtung aus dem aktuellen Input.
        /// </summary>
        private Vector3 GetCameraRelativeDirection()
        {
            var input = ReusableData.MoveInput;
            if (input.sqrMagnitude < 0.01f)
                return Vector3.zero;

            var cam = UnityEngine.Camera.main;
            if (cam == null)
                return new Vector3(input.x, 0f, input.y).normalized;

            var camForward = cam.transform.forward;
            var camRight = cam.transform.right;
            camForward.y = 0f;
            camRight.y = 0f;
            camForward.Normalize();
            camRight.Normalize();

            return (camForward * input.y + camRight * input.x).normalized;
        }
    }
}
```

### 2. Design-Entscheidungen

**Warum `base.OnUpdate()` nicht aufgerufen wird:**
- Analog zu `PlayerHardLandingState`: Coyote Time Check und Sliding-Check sind während einer Roll nicht sinnvoll
- Der State wartet auf Animation-Ende (oder Fallback-Timer)

**Warum OnJump() leer überschrieben wird:**
- Spezifikation: "Jump blockiert — verhindert Jump-Cancel der Roll-Animation"
- Kein Jump-Buffer wie bei HardLanding (Roll ist kürzer, Buffer wäre verwirrend)

**Warum MediumStop statt Idle bei keinem Input:**
- Spezifikation: Roll → MediumStop bei keinem Input (natürlicherer Übergang als abruptes Idle)

**Warum `ShouldSprint = false`:**
- Sprint ist während Roll nicht kombinierbar (Spec)
- Wird in OnEnter gesetzt, SprintHeld bleibt erhalten für Post-Roll Transition

## Verifikation

- [ ] `PlayerRollingState.cs` existiert in `States/Grounded/`
- [ ] Erbt von `PlayerGroundedState`
- [ ] `StateName` = "Rolling"
- [ ] OnEnter: Rotation sofort, SpeedModifier gesetzt, Sprint deaktiviert, Animation gestartet
- [ ] OnUpdate: Wartet auf CanExitAnimation/IsAnimationComplete, dann Transition
- [ ] OnJump: Leer (Jump blockiert)
- [ ] OnExit: SpeedModifier auf 1.0 zurückgesetzt
- [ ] Kompiliert fehlerfrei (Hinweis: StateMachine-Verdrahtung erst in 22.5)

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/States/Grounded/
├── PlayerRollingState.cs           ← NEU
```

---

→ Nächster Schritt: [22.5 StateMachine + FallingState Transition](22.5-statemachine-transition.md)
