# 22.4 PlayerRollingState implementieren

> **Commit:** `feat(phase-22): 22.4 PlayerRollingState`
> **Branch:** `feat/roll-state`

---

## Ziel

Den `PlayerRollingState` implementieren — Landing-State der bei hartem Aufprall mit Movement-Input den Character in Bewegungsrichtung rollen lässt.

---

## Anweisungen

### 1. PlayerRollingState erstellen

**Datei:** `Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/States/Grounded/PlayerRollingState.cs`

**Vererbung:** `PlayerRollingState : PlayerGroundedState`

### 2. Klassen-Struktur

```csharp
namespace Wiesenwischer.GameKit.CharacterController.StateMachine.States
{
    public class PlayerRollingState : PlayerGroundedState
    {
        private Vector3 _rollDirection;

        public PlayerRollingState(PlayerMovementStateMachine stateMachine)
            : base(stateMachine) { }

        protected override void OnEnter()
        {
            base.OnEnter();

            // 1. Roll-Richtung bestimmen (kamerarelativ)
            _rollDirection = GetCameraRelativeMoveDirection();
            if (_rollDirection.sqrMagnitude < 0.01f)
                _rollDirection = Player.transform.forward;
            _rollDirection.Normalize();

            // 2. Sofortige Rotation in Roll-Richtung
            Player.transform.rotation = Quaternion.LookRotation(_rollDirection);

            // 3. Speed Modifier setzen (RunSpeed * RollSpeedModifier)
            float rollSpeedModifier = Config.RunSpeed * Config.RollSpeedModifier / Config.WalkSpeed;
            ReusableData.MovementSpeedModifier = rollSpeedModifier;

            // 4. Sprint deaktivieren
            ReusableData.SprintHeld = false;

            // 5. Animation starten
            Player.AnimationController?.PlayState(CharacterAnimationState.Roll);
        }

        protected override void OnUpdate()
        {
            base.OnUpdate();

            // Prüfe ob Animation fertig ist (AllowExit Event oder IsAnimationComplete)
            var anim = Player.AnimationController;
            if (anim != null && (anim.CanExitAnimation || anim.IsAnimationComplete()))
            {
                TransitionToNextState();
                return;
            }

            // Fallback: Timer-basiert (falls kein AnimationController)
            if (anim == null && StateTimer > 0.7f)
            {
                TransitionToNextState();
                return;
            }
        }

        protected override void OnHandleInput()
        {
            // Jump während Roll blockiert — NICHT base.OnHandleInput() aufrufen
            // für Jump, aber Movement-Input für Rotation lesen
            ReadMovementInput();

            // Jump und Sprint bewusst ignorieren
        }

        protected override void OnExit()
        {
            base.OnExit();
        }

        private void TransitionToNextState()
        {
            if (ReusableData.MoveInput.sqrMagnitude > 0.01f)
            {
                // Mit Input → direkt zu Walk/Run/Sprint
                if (ReusableData.SprintHeld)
                    ChangeState(StateMachine.SprintingState);
                else if (ReusableData.ShouldWalk)
                    ChangeState(StateMachine.WalkingState);
                else
                    ChangeState(StateMachine.RunningState);
            }
            else
            {
                // Ohne Input → MediumStop (Abbremsen)
                ChangeState(StateMachine.MediumStoppingState);
            }
        }
    }
}
```

### 3. Wichtige Design-Entscheidungen

| Aspekt | Entscheidung | Begründung |
|--------|-------------|------------|
| Jump blockiert | `OnHandleInput()` ruft kein Jump-Check auf | Spec: Jump-Cancel der Roll-Animation verhindern |
| Sprint deaktiviert | `SprintHeld = false` bei Enter | Spec: Roll nicht mit Sprint kombinierbar |
| Rotation sofort | `Quaternion.LookRotation()` ohne SmoothDamp | Spec: Snappy Feel, sofortige Ausrichtung |
| Erbt von Grounded | Eigenständige Bewegungslogik | Spec: Nicht SoftLanding/HardLanding-Recovery-Pattern |
| AllowExit-Pattern | Animation Event + Fallback | Konsistent mit HardLandingState |

### 4. Hinweise zur Implementierung

- **Methoden-Namen:** Prüfe die exakten Override-Methoden im bestehenden Code (z.B. `OnEnter()` vs `Enter()`, `OnUpdate()` vs `Update()`). Orientiere dich am `PlayerHardLandingState`.
- **StateTimer:** Falls ein `StateTimer` in der Base-Klasse existiert, nutze ihn für den Fallback.
- **GetCameraRelativeMoveDirection:** Prüfe ob diese Methode in der Base-Klasse oder einem Utility existiert. Implementiere ggf. basierend auf `ReusableData.MoveInput` + Camera-Transform.

---

## Verifikation

- [ ] `PlayerRollingState.cs` kompiliert
- [ ] Erbt von `PlayerGroundedState`
- [ ] Setzt SpeedModifier basierend auf `Config.RollSpeedModifier`
- [ ] Blockiert Jump-Input
- [ ] Deaktiviert Sprint
- [ ] Rotation sofort in Bewegungsrichtung
- [ ] Transition nach Animation-Ende: → Moving (mit Input) oder → MediumStop (ohne)
- [ ] AllowExit/IsAnimationComplete Pattern implementiert

---

## Erwartete Dateien

```
Packages/.../Runtime/Core/StateMachine/States/Grounded/PlayerRollingState.cs   (NEU)
```

---

**Nächster Schritt:** [22.5 StateMachine + FallingState Transition](22.5-statemachine-transition.md)
