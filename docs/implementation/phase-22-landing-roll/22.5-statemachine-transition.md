# 22.5 StateMachine + FallingState Transition

> **Commit:** `feat(phase-22): 22.5 RollingState in StateMachine und FallingState-Transition`
> **Branch:** `feat/roll-transitions`

---

## Ziel

`PlayerRollingState` in die `PlayerMovementStateMachine` verdrahten und die `HandleLanding()`-Logik in `PlayerFallingState` erweitern, um die Roll-Bedingung zu prüfen.

## Anweisungen

### 1. PlayerMovementStateMachine erweitern

**Datei:** `Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/PlayerMovementStateMachine.cs`

**Property hinzufügen** (nach HardLandingState, im `Grounded State Instances`-Block):

```csharp
/// <summary>Rolling State - Roll bei hartem Aufprall mit Movement-Input.</summary>
public PlayerRollingState RollingState { get; }
```

**Im Constructor** (nach `HardLandingState` Initialisierung):

```csharp
RollingState = new PlayerRollingState(this);
```

### 2. PlayerFallingState.HandleLanding() erweitern

**Datei:** `Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/States/Airborne/PlayerFallingState.cs`

Die aktuelle `HandleLanding()` Methode:

```csharp
private void HandleLanding()
{
    // ... (Fallhöhe berechnen, LandingVelocity setzen)

    // Landing auf steiler Slope → direkt Sliding
    var groundInfo = Player.Locomotion.GroundInfo;
    if (groundInfo.SlopeAngle > Config.MaxSlopeAngle
        && Player.Locomotion.Motor.GroundingStatus.FoundAnyGround)
    {
        ChangeState(stateMachine.SlidingState);
        return;
    }

    if (landingSpeed >= Config.HardLandingThreshold)
    {
        ChangeState(stateMachine.HardLandingState);  // ← HIER ändern
    }
    else
    {
        ChangeState(stateMachine.SoftLandingState);
    }
}
```

**Ersetzen** des HardLanding-Blocks durch Roll-Prüfung:

```csharp
if (landingSpeed >= Config.HardLandingThreshold)
{
    // Roll-Condition prüfen
    if (ShouldRoll())
    {
        ChangeState(stateMachine.RollingState);
    }
    else
    {
        ChangeState(stateMachine.HardLandingState);
    }
}
else
{
    ChangeState(stateMachine.SoftLandingState);
}
```

### 3. ShouldRoll() Methode hinzufügen

In `PlayerFallingState`:

```csharp
/// <summary>
/// Prüft ob die Roll-Bedingung erfüllt ist.
/// Berücksichtigt Config (Enabled, TriggerMode) und aktuellen Input.
/// </summary>
private bool ShouldRoll()
{
    if (!Config.RollEnabled)
        return false;

    switch (Config.RollTriggerMode)
    {
        case RollTriggerMode.MovementInput:
            return ReusableData.MoveInput.sqrMagnitude > 0.01f;

        case RollTriggerMode.ButtonPress:
            return ReusableData.DashPressed;

        default:
            return false;
    }
}
```

**Hinweis zu `ReusableData.DashPressed`:** Falls dieses Feld noch nicht existiert, muss es vorbereitet werden (ist laut Spezifikation "bereits in ReusableData vorhanden"). Prüfe `PlayerStateReusableData.cs` und ergänze ggf.:

```csharp
/// <summary>Ob die Dash/Roll-Taste gedrückt ist (für ButtonPress Roll-Modus).</summary>
public bool DashPressed { get; set; }
```

### 4. Debug-Log aktualisieren

Das bestehende Debug-Log in `HandleLanding()` sollte den Roll-Fall berücksichtigen:

```csharp
#if UNITY_EDITOR
string landingType;
if (groundInfo.SlopeAngle > Config.MaxSlopeAngle && ...)
    landingType = "SLIDE";
else if (landingSpeed >= Config.HardLandingThreshold)
    landingType = ShouldRoll() ? "ROLL" : "HARD";
else
    landingType = "SOFT";

Debug.Log($"[FallingState] Landing! ... → {landingType}");
#endif
```

## Verifikation

- [ ] `PlayerMovementStateMachine` hat `RollingState` Property + Constructor-Initialisierung
- [ ] `PlayerFallingState.HandleLanding()` prüft `ShouldRoll()` vor HardLanding
- [ ] `ShouldRoll()` respektiert `RollEnabled`, `RollTriggerMode`, `MoveInput`
- [ ] Sliding-Check kommt weiterhin VOR dem Landing-Speed-Check (kein Regression)
- [ ] Debug-Log zeigt ROLL/HARD/SOFT/SLIDE korrekt an
- [ ] Kompiliert fehlerfrei
- [ ] Bestehende Landing-Logik (Soft/Hard) funktioniert unverändert wenn Roll deaktiviert

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/
├── PlayerMovementStateMachine.cs                              ← ERWEITERT
├── States/Airborne/PlayerFallingState.cs                      ← ERWEITERT
├── Data/PlayerStateReusableData.cs                            ← ggf. ERWEITERT (DashPressed)
```

---

→ Nächster Schritt: [22.6 Unit Tests](22.6-unit-tests.md)
