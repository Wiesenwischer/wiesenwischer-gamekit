# 7.6 Lag Compensation & Animation Smoothing

**Commit:** `feat(phase-7): 7.6 Lag Compensation`
**Branch:** `feat/animation-lag-compensation`

---

## Ziel

Animation-Timing für Netzwerk-Delay kompensieren. State-Wechsel kommen verzögert an — ohne Kompensation sehen Remote-Spieler die Animation zu spät starten. Außerdem: Smoothing für Parameter-Sprünge bei Packet Loss.

---

## Anweisungen

### 1. Transition-Dauer anpassen

Wenn ein State-Change über das Netzwerk ankommt, ist er bereits X ms alt. Die CrossFade-Transition kann gekürzt werden um den Delay zu kompensieren:

```csharp
// In NetworkAnimationSync.ObserverRpcAnimationState():
[ObserverRpc(ExcludeOwner = true)]
private void ObserverRpcAnimationState(byte stateValue, float timestamp)
{
    var state = (CharacterAnimationState)stateValue;

    // Netzwerk-Delay berechnen
    float networkDelay = (float)(TimeManager.ServerUptime - timestamp);
    networkDelay = Mathf.Clamp(networkDelay, 0f, 0.5f);

    // Transition-Dauer reduzieren (aber nie unter 0)
    float normalTransition = GetTransitionDuration(state);
    float adjustedTransition = Mathf.Max(0f, normalTransition - networkDelay);

    _animController?.PlayState(state, adjustedTransition);
}
```

### 2. Owner-Seite: Timestamp mitsenden

```csharp
// In NetworkAnimationSync:
public void OnLocalStateChanged(CharacterAnimationState state)
{
    if (!IsOwner) return;
    if (state == _lastSyncedState && _initialized) return;

    _lastSyncedState = state;
    _initialized = true;

    // Timestamp für Lag Compensation
    float timestamp = (float)TimeManager.ServerUptime;
    ServerRpcAnimationState((byte)state, timestamp);
}

[ServerRpc]
private void ServerRpcAnimationState(byte stateValue, float timestamp)
{
    _currentAnimState = stateValue;
    ObserverRpcAnimationState(stateValue, timestamp);
}
```

### 3. Parameter-Smoothing für Remote-Spieler

Bei Packet Loss können Parameter-Werte springen. Remote AnimatorParameterBridge braucht sanftes Damping:

```csharp
// In AnimatorParameterBridge (Remote-Mode erweitern):

[Header("Remote Smoothing")]
[SerializeField] private float _remoteSpeedDampTime = 0.15f;
[SerializeField] private float _remoteVelocityDampTime = 0.1f;

// In SetSpeed() / SetVerticalVelocity() für Remote:
public void SetSpeed(float speed)
{
    if (IsRemoteMode)
    {
        // Sanft zum Zielwert dampen
        _targetSpeed = speed;
        return;
    }
    _currentSpeed = speed;
}

private void ApplyParametersToAnimator()
{
    if (IsRemoteMode)
    {
        // Smooth Damping für Remote
        _currentSpeed = Mathf.MoveTowards(
            _currentSpeed, _targetSpeed,
            Time.deltaTime / _remoteSpeedDampTime);
    }

    _animator.SetFloat(AnimationParameters.SpeedHash,
        _currentSpeed, _speedDampTime, Time.deltaTime);
    // ... VerticalVelocity analog
}
```

### 4. Out-of-Order State Changes

Netzwerk-Pakete können in falscher Reihenfolge ankommen. State-Changes brauchen Sequence-Nummern:

```csharp
// In NetworkAnimationSync:
private ushort _stateSequence;

// Owner: Sequence erhöhen bei jedem State-Change
public void OnLocalStateChanged(CharacterAnimationState state)
{
    // ...
    _stateSequence++;
    ServerRpcAnimationState((byte)state, timestamp, _stateSequence);
}

// Remote: Nur neueren State akzeptieren
private ushort _lastReceivedSequence;

[ObserverRpc(ExcludeOwner = true)]
private void ObserverRpcAnimationState(
    byte stateValue, float timestamp, ushort sequence)
{
    // Veraltete States ignorieren
    if (IsSequenceOlder(sequence, _lastReceivedSequence)) return;
    _lastReceivedSequence = sequence;

    // ... State anwenden mit Lag Compensation ...
}

private bool IsSequenceOlder(ushort test, ushort reference)
{
    // Wrap-around safe comparison
    return (short)(test - reference) < 0;
}
```

### 5. Reconciliation-Korrektur für Animationen

Wenn Phase 6 einen Position-Rollback durchführt, muss der Animation-State möglicherweise auch korrigiert werden:

```csharp
// In NetworkStateSync (aus Phase 6) ergänzen:
private void PerformRollback(PredictionState serverState)
{
    // ... bestehende Position-Korrektur ...

    // Animation State aus Server-State ableiten
    // (StateName ist in PredictionState enthalten)
    if (!string.IsNullOrEmpty(serverState.StateName))
    {
        // Optional: Animation State korrigieren
        // In den meisten Fällen korrigiert sich der State
        // automatisch durch die Re-Simulation
    }
}
```

---

## Verifikation

- [ ] Bei 100ms Latenz: Animation-State-Wechsel sind visuell synchron (Transitions kürzer)
- [ ] Bei Packet Loss: Speed-Wert springt nicht, sondern dampt zum neuen Wert
- [ ] Out-of-order States: Alter State wird ignoriert, neuester gewinnt
- [ ] Extrem hohe Latenz (>300ms): Graceful Degradation (State-Wechsel direkt ohne Transition)
- [ ] Sequence Wrap-around (65535 → 0) funktioniert korrekt

---

## Erwartete Dateien

Geänderte Dateien:
- `NetworkAnimationSync.cs` — Timestamp + Sequence Number + Lag Compensation
- `AnimatorParameterBridge.cs` — Remote-Mode Smoothing (Damping)

---

## Hinweise

- **FishNet `TimeManager.ServerUptime`** liefert eine synchronisierte Zeitbasis für Server und Client
- Lag Compensation funktioniert nur approximativ — bei sehr hoher Latenz (>500ms) sieht man trotzdem Delay
- Parameter-Damping ist ein Trade-off: Mehr Damping = weniger Ruckler, aber mehr visuelle Latenz
- In der Praxis sehen 50-100ms Latenz mit Compensation fast identisch zu lokal aus

---

→ Nächster Schritt: [7.7 Unit Tests & Verifikation](7.7-unit-tests.md)
