# 7.5 IK Target Sync

**Commit:** `feat(phase-7): 7.5 IK Target Sync`
**Branch:** `feat/network-ik-sync`

---

## Ziel

LookAt-IK-Ziele über das Netzwerk synchronisieren, damit Remote-Spieler in die richtige Richtung schauen. Ein `NetworkLookAtTargetProvider` implementiert `IIKTargetProvider` für Remote-Spieler und empfängt Zielkoordinaten vom Netzwerk.

---

## Anweisungen

### 1. NetworkLookAtTargetProvider

Neue Klasse in `Network.FishNet/Runtime/Core/NetworkLookAtTargetProvider.cs`:

```csharp
using FishNet.Object;
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.IK;

namespace Wiesenwischer.GameKit.Network
{
    /// <summary>
    /// IIKTargetProvider für Remote-Spieler.
    /// Empfängt LookAt-Zielposition vom Netzwerk und interpoliert
    /// sie für flüssiges Head-Tracking.
    /// </summary>
    public class NetworkLookAtTargetProvider : NetworkBehaviour, IIKTargetProvider
    {
        [Header("Interpolation")]
        [SerializeField] private float _interpolationSpeed = 8f;

        [Header("Sync Settings")]
        [Tooltip("Sync-Rate in Ticks (bei 60Hz: 6 = 10 Hz)")]
        [SerializeField] private int _syncRate = 6;

        private Vector3 _targetPosition;
        private Vector3 _smoothedPosition;
        private bool _hasTarget;
        private int _ticksSinceSync;

        // Referenz auf den lokalen LookAt-Provider (nur Owner)
        private IIKTargetProvider _localProvider;

        public bool HasLookTarget => _hasTarget;

        public Vector3 GetLookTarget() => _smoothedPosition;

        public override void OnStartNetwork()
        {
            base.OnStartNetwork();

            if (IsOwner)
            {
                // Owner: Lokalen Provider finden (z.B. CameraTargetProvider)
                var providers = GetComponentsInChildren<IIKTargetProvider>();
                foreach (var p in providers)
                {
                    if (p != (IIKTargetProvider)this)
                    {
                        _localProvider = p;
                        break;
                    }
                }
            }
        }

        private void Update()
        {
            if (IsOwner)
            {
                OwnerUpdate();
            }
            else
            {
                RemoteUpdate();
            }
        }

        // === Owner: Lokales Target lesen und senden ===

        private void OwnerUpdate()
        {
            if (_localProvider == null) return;

            _ticksSinceSync++;
            if (_ticksSinceSync < _syncRate) return;
            _ticksSinceSync = 0;

            bool hasTarget = _localProvider.HasLookTarget;
            Vector3 target = hasTarget ? _localProvider.GetLookTarget() : Vector3.zero;

            ServerRpcSyncLookTarget(hasTarget, target);
        }

        [ServerRpc(Channel = FishNet.Transporting.Channel.Unreliable)]
        private void ServerRpcSyncLookTarget(bool hasTarget, Vector3 target)
        {
            ObserverRpcSyncLookTarget(hasTarget, target);
        }

        [ObserverRpc(ExcludeOwner = true,
            Channel = FishNet.Transporting.Channel.Unreliable)]
        private void ObserverRpcSyncLookTarget(bool hasTarget, Vector3 target)
        {
            _hasTarget = hasTarget;
            _targetPosition = target;
        }

        // === Remote: Target interpolieren ===

        private void RemoteUpdate()
        {
            if (!_hasTarget) return;

            _smoothedPosition = Vector3.Lerp(
                _smoothedPosition, _targetPosition,
                _interpolationSpeed * Time.deltaTime);
        }
    }
}
```

### 2. LookAtIK für Remote-Spieler konfigurieren

Remote-Spieler brauchen:
- `LookAtIK` Modul aktiv
- `IIKTargetProvider` = `NetworkLookAtTargetProvider` (statt CameraTargetProvider)
- `IKManager` aktiv

```csharp
// In NetworkPlayer.DisableRemotePlayerInput() ergänzen:
private void DisableRemotePlayerInput()
{
    // ... bestehende Logik ...

    // LookAt IK: Provider auf Network umstellen
    var lookAtIK = GetComponentInChildren<LookAtIK>();
    var networkProvider = GetComponent<NetworkLookAtTargetProvider>();
    if (lookAtIK != null && networkProvider != null)
    {
        // LookAtIK.SetTargetProvider(networkProvider)
        // oder via SerializeField im Inspector
    }
}
```

**Alternativ:** `LookAtIK` erweitern um `SetTargetProvider(IIKTargetProvider)`:

```csharp
// In LookAtIK:
public void SetTargetProvider(IIKTargetProvider provider)
{
    _target = provider;
}
```

### 3. Sichtbarkeits-Optimierung

IK-Targets nur senden wenn der Spieler vom Observer gesehen werden kann:

```csharp
// Optional: Renderer.isVisible check
private void OwnerUpdate()
{
    // ... bestehende Logik ...
    // Für Phase 7 reicht es ohne Visibility-Check.
    // Optimierung kann in einer späteren Phase ergänzt werden.
}
```

### 4. Player Prefab aktualisieren

```
Player (Root)
├── ...
├── NetworkLookAtTargetProvider   ← NEU
├── ...
└── Model (Child)
    ├── Animator
    ├── IKManager
    ├── LookAtIK (Target: NetworkLookAtTargetProvider für Remote)
    └── FootIK
```

---

## Verifikation

- [ ] Remote-Spieler dreht Kopf zum Look-Target des Owners
- [ ] Kopfbewegung ist flüssig (Interpolation)
- [ ] Wenn Owner kein Target hat → Remote-Spieler schaut geradeaus
- [ ] Bandbreite: ~12 Bytes/Paket (bool + Vector3) bei 10 Hz = ~120 Bytes/s
- [ ] Lokaler Spieler: Normales LookAt-IK unverändert
- [ ] Foot IK: Nicht synchronisiert (lokal, terrain-basiert) — korrekt

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.Network.FishNet/Runtime/Core/
└── NetworkLookAtTargetProvider.cs
```

Geänderte Dateien:
- `LookAtIK.cs` — `SetTargetProvider()` Methode
- `NetworkPlayer.cs` — Remote LookAt-Setup
- `Wiesenwischer.GameKit.Network.FishNet.Runtime.asmdef` — IK-Package-Referenz

---

## Hinweise

- **Foot IK** wird NICHT synchronisiert — jeder Client berechnet Foot IK lokal basierend auf dem eigenen Terrain. Das Ergebnis ist visuell korrekt weil die Position synchronisiert wird.
- **Hand IK** wird in Phase 9 (Combat) behandelt, wenn es tatsächlich Hand-IK-Targets gibt.
- LookAt-Target-Position relativ zum Spieler senden (statt World-Space) spart bei Floating Origin Bandbreite.

---

→ Nächster Schritt: [7.6 Lag Compensation & Smoothing](7.6-lag-compensation.md)
