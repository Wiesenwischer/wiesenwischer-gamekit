# 7.4 Ability Animation Sync

**Commit:** `feat(phase-7): 7.4 Ability Animation Sync`
**Branch:** `feat/network-ability-sync`

---

## Ziel

Ability-Animationen (Animator Layer 1) über das Netzwerk synchronisieren. Wenn ein Spieler eine Ability aktiviert (z.B. Angriff, Zauber), sehen Remote-Clients die zugehörige Animation auf Layer 1.

---

## Anweisungen

### 1. NetworkAbilitySync Komponente

Neue Klasse in `Network.FishNet/Runtime/Core/NetworkAbilitySync.cs`:

```csharp
using FishNet.Object;
using FishNet.Object.Synchronizing;
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core.Animation;
using Wiesenwischer.GameKit.Abilities.Core;

namespace Wiesenwischer.GameKit.Network
{
    /// <summary>
    /// Synchronisiert Ability-Animationen über das Netzwerk.
    /// Lauscht auf AbilitySystem Events und broadcastet:
    /// - Layer-Weight-Änderungen (0 → 1 bei Aktivierung, 1 → 0 bei Deaktivierung)
    /// - Ability Animation State Name (für CrossFade auf Layer 1)
    /// </summary>
    [RequireComponent(typeof(NetworkPlayer))]
    public class NetworkAbilitySync : NetworkBehaviour
    {
        private AbilitySystem _abilitySystem;
        private IAnimationController _animController;

        // SyncVars für aktuellen Ability-State
        [SyncVar(OnChange = nameof(OnAbilityLayerWeightChanged))]
        private float _abilityLayerWeight;

        [SyncVar(OnChange = nameof(OnAbilityAnimChanged))]
        private string _abilityAnimStateName = "";

        [SyncVar]
        private float _abilityTransitionDuration;

        public override void OnStartNetwork()
        {
            base.OnStartNetwork();
            _abilitySystem = GetComponent<AbilitySystem>();
            _animController = GetComponentInChildren<IAnimationController>();

            if (IsOwner && _abilitySystem != null)
            {
                _abilitySystem.OnAbilityActivated += OnAbilityActivated;
                _abilitySystem.OnAbilityDeactivated += OnAbilityDeactivated;
                _abilitySystem.OnAbilityCancelled += OnAbilityCancelled;
            }
        }

        public override void OnStopNetwork()
        {
            base.OnStopNetwork();
            if (_abilitySystem != null)
            {
                _abilitySystem.OnAbilityActivated -= OnAbilityActivated;
                _abilitySystem.OnAbilityDeactivated -= OnAbilityDeactivated;
                _abilitySystem.OnAbilityCancelled -= OnAbilityCancelled;
            }
        }

        // === Owner: Ability Events erfassen ===

        private void OnAbilityActivated(IAbility ability)
        {
            if (!IsOwner) return;

            ServerRpcAbilityActivated(
                GetAnimStateName(ability),
                GetTransitionDuration(ability));
        }

        private void OnAbilityDeactivated(IAbility ability)
        {
            if (!IsOwner) return;
            ServerRpcAbilityDeactivated();
        }

        private void OnAbilityCancelled(IAbility ability)
        {
            if (!IsOwner) return;
            ServerRpcAbilityDeactivated();
        }

        // === Server RPCs ===

        [ServerRpc]
        private void ServerRpcAbilityActivated(
            string animStateName, float transitionDuration)
        {
            _abilityLayerWeight = 1f;
            _abilityAnimStateName = animStateName ?? "";
            _abilityTransitionDuration = transitionDuration;
        }

        [ServerRpc]
        private void ServerRpcAbilityDeactivated()
        {
            _abilityLayerWeight = 0f;
            _abilityAnimStateName = "";
        }

        // === SyncVar Callbacks (auf Remote-Clients) ===

        private void OnAbilityLayerWeightChanged(
            float prev, float next, bool asServer)
        {
            if (IsOwner) return;
            _animController?.SetAbilityLayerWeight(next);
        }

        private void OnAbilityAnimChanged(
            string prev, string next, bool asServer)
        {
            if (IsOwner) return;
            if (!string.IsNullOrEmpty(next))
            {
                _animController?.PlayAbilityAnimation(
                    next, _abilityTransitionDuration);
            }
        }

        // === Hilfsmethoden ===

        private string GetAnimStateName(IAbility ability)
        {
            if (ability is IAbilityAnimationHandler handler)
                return handler.AnimationStateName;
            return null;
        }

        private float GetTransitionDuration(IAbility ability)
        {
            if (ability is IAbilityAnimationHandler handler)
                return handler.TransitionDuration;
            return 0.1f;
        }
    }
}
```

### 2. asmdef-Abhängigkeit

`Wiesenwischer.GameKit.Network.FishNet.Runtime.asmdef` braucht eine Referenz auf das Abilities-Package:

```json
{
    "references": [
        "Wiesenwischer.GameKit.CharacterController.Core.Runtime",
        "Wiesenwischer.GameKit.Abilities.Core",
        "FishNet.Runtime"
    ]
}
```

### 3. Player Prefab aktualisieren

`NetworkAbilitySync` zum Player Prefab hinzufügen:

```
Player (Root)
├── NetworkObject
├── NetworkPlayer
├── NetworkInputSync
├── NetworkStateSync
├── NetworkAnimationSync
├── NetworkAbilitySync        ← NEU
├── RemotePlayerInterpolator
├── PlayerController
├── AbilitySystem
├── CharacterMotor
└── ...
```

---

## Verifikation

- [ ] Spieler A aktiviert Ability → Spieler B sieht Layer-1-Animation
- [ ] Ability endet → Layer-Weight geht auf 0 bei Remote
- [ ] Ability wird cancelled → Layer-Weight geht sofort auf 0
- [ ] SyncVar sendet Initial-State an spät verbindende Clients
- [ ] Ohne registrierte Abilities: Kein Effekt
- [ ] Offline-Modus: Keine Regression

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.Network.FishNet/Runtime/Core/
└── NetworkAbilitySync.cs
```

Geänderte Dateien:
- `Wiesenwischer.GameKit.Network.FishNet.Runtime.asmdef` — Abilities-Referenz

---

## Hinweise

- **SyncVar** vs **ObserverRpc**: SyncVars sind ideal für "aktuellen Zustand" der auch spät verbindenden Clients bekannt sein muss. ObserverRpc ist für einmalige Events.
- Hier nutzen wir SyncVar, weil der Ability-State persistent ist (ein neuer Client muss wissen ob gerade eine Ability aktiv ist).
- String-Sync (`_abilityAnimStateName`) ist nicht ideal für Bandbreite, aber Ability-Aktivierungen sind selten (< 1/s).

---

→ Nächster Schritt: [7.5 IK Target Sync](7.5-ik-target-sync.md)
