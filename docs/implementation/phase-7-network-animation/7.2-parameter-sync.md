# 7.2 Animator Parameter Sync

**Commit:** `feat(phase-7): 7.2 Animator Parameter Sync`
**Branch:** `feat/network-parameter-sync`

---

## Ziel

Kontinuierliche Animator-Parameter (Speed, VerticalVelocity) periodisch an Remote-Clients senden. Quantisiert für minimale Bandbreite.

---

## Anweisungen

### 1. AnimationSnapshot Struct

Neues Struct in `Network.FishNet/Runtime/Core/AnimationSnapshot.cs`:

```csharp
using System;

namespace Wiesenwischer.GameKit.Network
{
    /// <summary>
    /// Kompakter Snapshot der Animation-Parameter für Netzwerk-Übertragung.
    /// Speed: 0-2.0 → quantisiert als byte (0-255, Auflösung ~0.008)
    /// VerticalVelocity: -50..+20 → quantisiert als short (-500..+200, Auflösung 0.1)
    /// </summary>
    [Serializable]
    public struct AnimationSnapshot : IEquatable<AnimationSnapshot>
    {
        public byte SpeedQuantized;
        public short VerticalVelocityQuantized;

        // Quantisierung
        private const float SpeedMax = 2f;
        private const float VelocityMin = -50f;
        private const float VelocityMax = 20f;
        private const float VelocityScale = 10f;  // 0.1 Auflösung

        public float Speed
        {
            get => SpeedQuantized / 255f * SpeedMax;
            set => SpeedQuantized = (byte)(Mathf.Clamp01(value / SpeedMax) * 255);
        }

        public float VerticalVelocity
        {
            get => VerticalVelocityQuantized / VelocityScale;
            set => VerticalVelocityQuantized = (short)(
                Mathf.Clamp(value, VelocityMin, VelocityMax) * VelocityScale);
        }

        public static AnimationSnapshot Create(float speed, float verticalVelocity)
        {
            var snapshot = new AnimationSnapshot();
            snapshot.Speed = speed;
            snapshot.VerticalVelocity = verticalVelocity;
            return snapshot;
        }

        public bool Equals(AnimationSnapshot other)
        {
            return SpeedQuantized == other.SpeedQuantized
                && VerticalVelocityQuantized == other.VerticalVelocityQuantized;
        }
    }
}
```

### 2. NetworkAnimationSync um Parameter-Sync erweitern

```csharp
// In NetworkAnimationSync:

[Header("Parameter Sync")]
[SerializeField] private int _parameterSyncRate = 3;  // Alle 3 Ticks (~20 Hz)

private AnimationSnapshot _lastSnapshot;
private int _ticksSinceLastParamSync;

private void Update()
{
    if (!IsOwner) return;

    _ticksSinceLastParamSync++;
    if (_ticksSinceLastParamSync >= _parameterSyncRate)
    {
        SyncParameters();
        _ticksSinceLastParamSync = 0;
    }
}

private void SyncParameters()
{
    // Parameter aus dem aktuellen Animation-State lesen
    var snapshot = AnimationSnapshot.Create(
        speed: GetCurrentSpeed(),
        verticalVelocity: GetCurrentVerticalVelocity()
    );

    // Nur senden wenn sich etwas geändert hat
    if (snapshot.Equals(_lastSnapshot)) return;

    _lastSnapshot = snapshot;
    ServerRpcAnimationParams(snapshot);
}

[ServerRpc(Channel = FishNet.Transporting.Channel.Unreliable)]
private void ServerRpcAnimationParams(AnimationSnapshot snapshot)
{
    ObserverRpcAnimationParams(snapshot);
}

[ObserverRpc(ExcludeOwner = true,
    Channel = FishNet.Transporting.Channel.Unreliable)]
private void ObserverRpcAnimationParams(AnimationSnapshot snapshot)
{
    // Remote: Parameter anwenden
    _animController?.SetSpeed(snapshot.Speed);
    _animController?.SetVerticalVelocity(snapshot.VerticalVelocity);
}
```

### 3. Speed/VerticalVelocity auslesen

`AnimatorParameterBridge` braucht Getter für die aktuellen Werte:

```csharp
// In IAnimationController (Core Interface) ergänzen:
float CurrentSpeed { get; }
float CurrentVerticalVelocity { get; }

// In AnimatorParameterBridge implementieren:
public float CurrentSpeed => _currentSpeed;
public float CurrentVerticalVelocity => _currentVerticalVelocity;
```

### 4. Unreliable Channel

Parameter werden über den **Unreliable Channel** gesendet:
- Kein Packet-Loss-Retry (nächstes Update ersetzt veraltete Daten)
- Niedrigere Latenz
- Weniger Bandbreite als Reliable
- Für kontinuierliche Daten optimal

---

## Verifikation

- [ ] Remote-Spieler zeigen korrekte Laufgeschwindigkeit (Idle ↔ Walk ↔ Run ↔ Sprint)
- [ ] Jump/Fall-Blending stimmt (VerticalVelocity korrekt)
- [ ] Quantisierung verursacht keine sichtbaren Artefakte
- [ ] Bandbreite: ~3 Bytes/Paket bei 20 Hz = ~60 Bytes/s pro Spieler
- [ ] Keine Sends wenn Parameter sich nicht ändern (Idle-Optimierung)

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.Network.FishNet/Runtime/Core/
└── AnimationSnapshot.cs
```

Geänderte Dateien:
- `NetworkAnimationSync.cs` — Parameter-Sync-Logik
- `IAnimationController.cs` — `CurrentSpeed` / `CurrentVerticalVelocity` Properties
- `AnimatorParameterBridge.cs` — Properties implementieren

---

→ Nächster Schritt: [7.3 Remote Player Animation Setup](7.3-remote-animation-setup.md)
