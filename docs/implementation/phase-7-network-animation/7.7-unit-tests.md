# 7.7 Unit Tests & Verifikation

**Commit:** `test(phase-7): 7.7 Network Animation Tests`
**Branch:** `test/network-animation-tests`

---

## Ziel

Unit Tests für Animation-Sync-Datenstrukturen, Quantisierung und Lag Compensation. Play-Mode-Verifikation mit zwei Spielern.

---

## Anweisungen

### 1. AnimationSnapshot Tests

**Datei:** `Network.FishNet/Tests/Runtime/Core/AnimationSnapshotTests.cs`

```csharp
using NUnit.Framework;

namespace Wiesenwischer.GameKit.Network.Tests
{
    [TestFixture]
    public class AnimationSnapshotTests
    {
        [Test]
        public void Speed_Quantization_PreservesRange()
        {
            var snapshot = AnimationSnapshot.Create(speed: 1.0f, verticalVelocity: 0f);
            Assert.AreEqual(1.0f, snapshot.Speed, 0.01f);
        }

        [Test]
        public void Speed_Zero_IsZero()
        {
            var snapshot = AnimationSnapshot.Create(speed: 0f, verticalVelocity: 0f);
            Assert.AreEqual(0f, snapshot.Speed, 0.01f);
        }

        [Test]
        public void Speed_Max_IsClamped()
        {
            var snapshot = AnimationSnapshot.Create(speed: 5f, verticalVelocity: 0f);
            Assert.AreEqual(2f, snapshot.Speed, 0.02f);  // Clamped to SpeedMax
        }

        [Test]
        public void VerticalVelocity_Quantization_PreservesSign()
        {
            var up = AnimationSnapshot.Create(speed: 0f, verticalVelocity: 10f);
            var down = AnimationSnapshot.Create(speed: 0f, verticalVelocity: -30f);

            Assert.Greater(up.VerticalVelocity, 0f);
            Assert.Less(down.VerticalVelocity, 0f);
        }

        [Test]
        public void VerticalVelocity_Precision()
        {
            var snapshot = AnimationSnapshot.Create(speed: 0f, verticalVelocity: -9.81f);
            Assert.AreEqual(-9.81f, snapshot.VerticalVelocity, 0.1f);  // 0.1 Auflösung
        }

        [Test]
        public void Equality_SameValues_AreEqual()
        {
            var a = AnimationSnapshot.Create(1f, -5f);
            var b = AnimationSnapshot.Create(1f, -5f);
            Assert.IsTrue(a.Equals(b));
        }

        [Test]
        public void Equality_DifferentValues_AreNotEqual()
        {
            var a = AnimationSnapshot.Create(1f, -5f);
            var b = AnimationSnapshot.Create(0.5f, -5f);
            Assert.IsFalse(a.Equals(b));
        }

        [Test]
        public void ByteSize_IsCompact()
        {
            // SpeedQuantized (1 byte) + VerticalVelocityQuantized (2 bytes) = 3 bytes
            Assert.AreEqual(1, sizeof(byte));   // Speed
            Assert.AreEqual(2, sizeof(short));  // VerticalVelocity
            // Total: 3 bytes per snapshot
        }
    }
}
```

### 2. Sequence Number Tests

**Datei:** `Network.FishNet/Tests/Runtime/Core/SequenceTests.cs`

```csharp
using NUnit.Framework;

namespace Wiesenwischer.GameKit.Network.Tests
{
    [TestFixture]
    public class SequenceTests
    {
        [Test]
        public void NewerSequence_IsAccepted()
        {
            Assert.IsFalse(IsSequenceOlder(5, 3));  // 5 is newer than 3
        }

        [Test]
        public void OlderSequence_IsRejected()
        {
            Assert.IsTrue(IsSequenceOlder(3, 5));  // 3 is older than 5
        }

        [Test]
        public void SameSequence_IsRejected()
        {
            Assert.IsFalse(IsSequenceOlder(5, 5));  // Same = not older
        }

        [Test]
        public void WrapAround_NewerIsAccepted()
        {
            // 65535 → 0 → 1 wrap-around
            Assert.IsFalse(IsSequenceOlder(1, 65534));  // 1 is "newer" after wrap
        }

        [Test]
        public void WrapAround_OlderIsRejected()
        {
            // 65534 is older than 1 (after wrap)
            Assert.IsTrue(IsSequenceOlder(65534, 1));
        }

        private bool IsSequenceOlder(ushort test, ushort reference)
        {
            return (short)(test - reference) < 0;
        }
    }
}
```

### 3. CharacterAnimationState Serialization Tests

**Datei:** `Network.FishNet/Tests/Runtime/Core/AnimationStateSyncTests.cs`

```csharp
using NUnit.Framework;
using Wiesenwischer.GameKit.CharacterController.Core.Animation;

namespace Wiesenwischer.GameKit.Network.Tests
{
    [TestFixture]
    public class AnimationStateSyncTests
    {
        [Test]
        public void AllStates_FitInByte()
        {
            // CharacterAnimationState enum muss als byte serialisierbar sein
            var states = System.Enum.GetValues(typeof(CharacterAnimationState));
            foreach (CharacterAnimationState state in states)
            {
                int value = (int)state;
                Assert.LessOrEqual(value, 255,
                    $"State {state} ({value}) passt nicht in byte");
            }
        }

        [Test]
        public void ByteRoundTrip_PreservesState()
        {
            foreach (CharacterAnimationState state in
                System.Enum.GetValues(typeof(CharacterAnimationState)))
            {
                byte serialized = (byte)state;
                var deserialized = (CharacterAnimationState)serialized;
                Assert.AreEqual(state, deserialized);
            }
        }

        [Test]
        public void StateCount_IsCorrect()
        {
            // 11 States: Locomotion, Jump, Fall, SoftLand, HardLand,
            //             Roll, LightStop, MediumStop, HardStop, Slide, Crouch
            var count = System.Enum.GetValues(typeof(CharacterAnimationState)).Length;
            Assert.AreEqual(11, count);
        }
    }
}
```

### 4. Lag Compensation Tests

**Datei:** `Network.FishNet/Tests/Runtime/Core/LagCompensationTests.cs`

```csharp
using NUnit.Framework;
using UnityEngine;

namespace Wiesenwischer.GameKit.Network.Tests
{
    [TestFixture]
    public class LagCompensationTests
    {
        [Test]
        public void TransitionAdjustment_ReducesByDelay()
        {
            float normalTransition = 0.15f;
            float networkDelay = 0.05f;

            float adjusted = Mathf.Max(0f, normalTransition - networkDelay);

            Assert.AreEqual(0.1f, adjusted, 0.001f);
        }

        [Test]
        public void TransitionAdjustment_NeverNegative()
        {
            float normalTransition = 0.05f;
            float networkDelay = 0.2f;  // Delay > Transition

            float adjusted = Mathf.Max(0f, normalTransition - networkDelay);

            Assert.AreEqual(0f, adjusted, 0.001f);
        }

        [Test]
        public void TransitionAdjustment_ZeroDelay_NoChange()
        {
            float normalTransition = 0.15f;
            float networkDelay = 0f;

            float adjusted = Mathf.Max(0f, normalTransition - networkDelay);

            Assert.AreEqual(0.15f, adjusted, 0.001f);
        }

        [Test]
        public void DelayClamp_MaxHalfSecond()
        {
            float rawDelay = 2.0f;  // Extremer Delay
            float clamped = Mathf.Clamp(rawDelay, 0f, 0.5f);
            Assert.AreEqual(0.5f, clamped, 0.001f);
        }
    }
}
```

### 5. Play Mode Verifikation

Manuelle Verifikation im Unity Editor:

**Test-Checkliste:**
1. Host starten, Client verbinden
2. **Locomotion-Sync:**
   - Host läuft → Client sieht Lauf-Animation
   - Host sprintet → Client sieht Sprint-Animation
   - Host steht → Client sieht Idle
3. **State-Transitions:**
   - Host springt → Client sieht Jump + Fall + Landing
   - Host croucht → Client sieht Crouch-Animation
   - Host rollt (Fall + Bewegungsinput) → Client sieht Roll
4. **Blend-Trees:**
   - Host geht langsam → Client zeigt Walk-Blend
   - Host beschleunigt → flüssiger Übergang zu Run/Sprint
5. **LookAt IK:**
   - Host schaut nach links → Remote-Spieler dreht Kopf nach links
   - Host schaut nach oben → Remote-Spieler Kopf folgt
6. **Latenz-Test:**
   - Tugboat Latency Simulation: 100ms
   - State-Wechsel sollten fast synchron wirken
   - Keine sichtbaren Animation-Sprünge
7. **Packet Loss:**
   - Tugboat Loss Simulation: 5%
   - Speed-Parameter dampt sanft (kein Ruckeln)
8. **Neuer Client:**
   - Mitten im Spiel verbinden
   - Remote-Spieler sofort in korrekter Animation (Initial State via SyncVar)

---

## Verifikation

- [ ] Alle Unit Tests grün (AnimationSnapshot, Sequence, State, LagCompensation)
- [ ] Play Mode: Locomotion-Sync korrekt
- [ ] Play Mode: State-Transitions korrekt
- [ ] Play Mode: LookAt IK synchron
- [ ] Play Mode: Lag Compensation funktioniert
- [ ] Offline-Modus: Keine Regression

---

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.Network.FishNet/Tests/Runtime/Core/
├── AnimationSnapshotTests.cs
├── SequenceTests.cs
├── AnimationStateSyncTests.cs
└── LagCompensationTests.cs
```

---

→ Phase 7 abgeschlossen! Das Netzwerk-Epic (Phasen 6+7) ist damit komplett.
