# 25.1 FootLock Modul implementieren

> **Commit-Message:** `feat(phase-25): 25.1 FootLock Modul mit Velocity-Erkennung`
> **Branch:** `feat/footlock-module`

---

## Ziel

Neues IK-Modul `FootLock` erstellen, das Füße per Velocity-Erkennung automatisch an ihrer Position festnagelt. Verhindert Foot Sliding bei Animations-Übergängen.

## Datei

`Packages/Wiesenwischer.GameKit.CharacterController.IK/Runtime/Modules/FootLock.cs`

## Implementierung

### Klassen-Signatur

```csharp
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core;

namespace Wiesenwischer.GameKit.CharacterController.IK.Modules
{
    public class FootLock : MonoBehaviour, IIKModule
    {
        // IIKModule
        public string Name => "FootLock";
        public bool IsEnabled { get => _isEnabled; set => _isEnabled = value; }
        public float Weight { get => _weight; set => _weight = Mathf.Clamp01(value); }
    }
}
```

### SerializeField Parameter

```csharp
[Header("References")]
[SerializeField] private PlayerController _playerController;

[Header("Detection")]
[Tooltip("Geschwindigkeit (m/s) unter der ein Fuß als stehend gilt.")]
[SerializeField] private float _lockVelocityThreshold = 0.05f;

[Tooltip("Geschwindigkeit (m/s) über der ein Lock gelöst wird.")]
[SerializeField] private float _releaseVelocityThreshold = 0.15f;

[Tooltip("Frames unter Lock-Threshold bevor Lock greift.")]
[SerializeField] private int _stableFramesRequired = 2;

[Header("Release")]
[Tooltip("Smooth Blend-Out Zeit beim Lösen (Sekunden).")]
[SerializeField] private float _releaseDuration = 0.15f;

[Tooltip("Maximaler Abstand (m) zwischen gelockter und animierter Position. Darüber wird Lock gelöst.")]
[SerializeField] private float _maxLockDistance = 0.3f;

[Header("IK Settings")]
[Range(0f, 1f)]
[SerializeField] private float _weight = 1f;

private bool _isEnabled = true;
```

### Interne Felder

Per-Fuß Zustand mit `struct FootState` für Übersichtlichkeit:

```csharp
private struct FootState
{
    public bool IsLocked;
    public bool IsReleasing;
    public Vector3 LockedLocalPos;
    public Quaternion LockedLocalRot;
    public Vector3 PrevWorldPos;
    public int StableCount;
    public float ReleaseTimer;
}

private FootState _leftFoot;
private FootState _rightFoot;
```

### Öffentliche Properties (für FootIK-Koordination)

```csharp
public bool IsLeftFootLocked => _leftFoot.IsLocked || _leftFoot.IsReleasing;
public bool IsRightFootLocked => _rightFoot.IsLocked || _rightFoot.IsReleasing;
```

**Wichtig:** `IsReleasing` zählt ebenfalls als "locked", da FootLock während des Release-Blend noch IK-Gewicht setzt und FootIK nicht gleichzeitig eingreifen soll.

### Referenzen

```csharp
private IKManager _ikManager;
private Transform _rootTransform; // Player-Root, NICHT Model-Transform

private void Awake()
{
    _ikManager = GetComponent<IKManager>();
    if (_playerController == null)
        _playerController = GetComponentInParent<PlayerController>();
    // Root-Transform = PlayerController's Transform (Player-Root-Object)
    _rootTransform = _playerController != null ? _playerController.transform : transform.parent;
}

private void OnEnable()
{
    _ikManager?.RegisterModule(this);
}

private void OnDisable()
{
    _ikManager?.UnregisterModule(this);
}
```

### PrepareIK — Velocity-Erkennung

```csharp
public void PrepareIK()
{
    var animator = GetComponent<Animator>();
    if (animator == null || !animator.isHuman) return;

    var leftFootBone = animator.GetBoneTransform(HumanBodyBones.LeftFoot);
    var rightFootBone = animator.GetBoneTransform(HumanBodyBones.RightFoot);
    if (leftFootBone == null || rightFootBone == null) return;

    bool isGrounded = _playerController != null && _playerController.IsGrounded;

    UpdateFootLock(leftFootBone, ref _leftFoot, isGrounded);
    UpdateFootLock(rightFootBone, ref _rightFoot, isGrounded);
}
```

### UpdateFootLock — Kern-Logik pro Fuß

```csharp
private void UpdateFootLock(Transform footBone, ref FootState state, bool isGrounded)
{
    Vector3 worldPos = footBone.position;

    // Velocity berechnen (Division durch 0 vermeiden)
    float velocity = Time.deltaTime > 0f
        ? (worldPos - state.PrevWorldPos).magnitude / Time.deltaTime
        : 0f;
    state.PrevWorldPos = worldPos;

    if (state.IsLocked)
    {
        // Sicherheits-Check: Lock lösen wenn Fuß zu weit weg
        Vector3 lockedWorldPos = _rootTransform.TransformPoint(state.LockedLocalPos);
        if ((worldPos - lockedWorldPos).magnitude > _maxLockDistance)
        {
            state.IsLocked = false;
            state.IsReleasing = true;
            state.ReleaseTimer = 0f;
            return;
        }

        // Release-Check: Fuß bewegt sich wieder
        if (velocity > _releaseVelocityThreshold)
        {
            state.IsLocked = false;
            state.IsReleasing = true;
            state.ReleaseTimer = 0f;
        }
    }
    else if (!state.IsReleasing)
    {
        // Lock-Check: Fuß steht still + am Boden
        if (velocity < _lockVelocityThreshold && isGrounded)
        {
            state.StableCount++;
            if (state.StableCount >= _stableFramesRequired)
            {
                state.LockedLocalPos = _rootTransform.InverseTransformPoint(worldPos);
                state.LockedLocalRot = Quaternion.Inverse(_rootTransform.rotation) * footBone.rotation;
                state.IsLocked = true;
                state.StableCount = 0;
            }
        }
        else
        {
            state.StableCount = 0;
        }
    }

    // Release Blend-Out Timer
    if (state.IsReleasing)
    {
        state.ReleaseTimer += Time.deltaTime;
        if (state.ReleaseTimer >= _releaseDuration)
            state.IsReleasing = false;
    }
}
```

### ProcessIK — Gelockte Position anwenden

```csharp
public void ProcessIK(Animator animator, int layerIndex)
{
    if (layerIndex != 0) return;

    ApplyFootLock(animator, AvatarIKGoal.LeftFoot, _leftFoot);
    ApplyFootLock(animator, AvatarIKGoal.RightFoot, _rightFoot);
}

private void ApplyFootLock(Animator animator, AvatarIKGoal goal, FootState state)
{
    if (!state.IsLocked && !state.IsReleasing) return;

    float weight = _weight;
    if (state.IsReleasing)
        weight *= 1f - Mathf.Clamp01(state.ReleaseTimer / _releaseDuration);

    Vector3 worldPos = _rootTransform.TransformPoint(state.LockedLocalPos);
    Quaternion worldRot = _rootTransform.rotation * state.LockedLocalRot;

    animator.SetIKPositionWeight(goal, weight);
    animator.SetIKRotationWeight(goal, weight);
    animator.SetIKPosition(goal, worldPos);
    animator.SetIKRotation(goal, worldRot);
}
```

### Testbare Kern-Methode (internal)

Für Unit Tests ohne MonoBehaviour:

```csharp
internal static FootState CalculateFootLock(
    Vector3 footWorldPos,
    Quaternion footWorldRot,
    Vector3 rootPosition,
    Quaternion rootRotation,
    FootState state,
    bool isGrounded,
    float deltaTime,
    float lockThreshold,
    float releaseThreshold,
    int stableFramesRequired,
    float releaseDuration,
    float maxLockDistance)
{
    // Gleiche Logik wie UpdateFootLock, aber ohne MonoBehaviour-Abhängigkeit
    // Velocity, Lock/Release, Timer — alles als Pure Function
}
```

## Verifikation

- [ ] Datei kompiliert fehlerfrei
- [ ] Implementiert `IIKModule` korrekt (Name, IsEnabled, Weight, PrepareIK, ProcessIK)
- [ ] Registriert/Deregistriert sich beim IKManager
- [ ] `IsLeftFootLocked` / `IsRightFootLocked` Properties verfügbar
- [ ] Verwendet `_rootTransform` (Player-Root) für Local-Space-Berechnung
- [ ] `CalculateFootLock` internal-Methode für Unit Tests vorhanden

## Erwartete Dateien

```
Packages/Wiesenwischer.GameKit.CharacterController.IK/
└── Runtime/Modules/FootLock.cs  (NEU)
```

---

**Nächster Schritt:** [25.2 FootIK Koordination](25.2-footik-coordination.md)
