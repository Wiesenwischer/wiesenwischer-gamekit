# 20.1 GroundingSmoother Komponente implementieren

> **Branch:** `feat/grounding-smoother-component`
> **Commit:** `feat(phase-20): 20.1 GroundingSmoother Komponente`

---

## Ziel

`GroundingSmoother` MonoBehaviour erstellen, die den Y-Offset des Model-Child-Objects per `SmoothDamp` interpoliert, um diskrete Step-Up-Teleportationen des Motors visuell zu glätten.

---

## Dateien

| Aktion | Pfad |
|--------|------|
| Erstellen | `Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/Visual/GroundingSmoother.cs` |

---

## Namespace & Ordner

```
Packages/Wiesenwischer.GameKit.CharacterController.Core/
└── Runtime/Core/
    └── Visual/                 ← NEU
        └── GroundingSmoother.cs
```

**Namespace:** `Wiesenwischer.GameKit.CharacterController.Core.Visual`

---

## Detaillierte Anweisungen

### Klassen-Struktur

```csharp
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core.Motor;
using Wiesenwischer.GameKit.CharacterController.Core.Locomotion;

namespace Wiesenwischer.GameKit.CharacterController.Core.Visual
{
    /// <summary>
    /// Glättet visuelle Y-Sprünge bei Step-Ups (Treppen/Kanten).
    /// Versetzt das Model-Child temporär nach unten und löst den Offset per SmoothDamp auf.
    /// </summary>
    [RequireComponent(typeof(CharacterMotor))]
    public class GroundingSmoother : MonoBehaviour
    {
        // ... (siehe unten)
    }
}
```

### Serialisierte Felder

| Feld | Typ | Default | Tooltip |
|------|-----|---------|---------|
| `_modelTransform` | Transform | — | Transform des visuellen Modells (Child-Object mit Animator) |
| `_smoothTime` | float | 0.075f | Smooth-Zeit für Y-Offset-Auflösung (Sekunden) |
| `_maxStepDelta` | float | 0.5f | Maximaler Y-Sprung der als Step-Up erkannt wird (m) |
| `_onlyWhenGrounded` | bool | true | Nur smoothen wenn Character am Boden ist |

### Private Felder

| Feld | Typ | Beschreibung |
|------|-----|-------------|
| `_previousMotorY` | float | Motor-Y vom letzten Frame |
| `_smoothOffset` | float | Aktueller visueller Y-Offset |
| `_smoothVelocity` | float | SmoothDamp-Velocity (ref-Parameter) |
| `_motor` | CharacterMotor | Cached in Awake |
| `_locomotion` | CharacterLocomotion | Cached in Awake |

### Awake

```csharp
private void Awake()
{
    _motor = GetComponent<CharacterMotor>();
    _locomotion = GetComponent<CharacterLocomotion>();
}
```

### OnEnable

```csharp
private void OnEnable()
{
    _previousMotorY = _motor.TransientPosition.y;
    _smoothOffset = 0f;
    _smoothVelocity = 0f;
}
```

### LateUpdate — Algorithmus

Die gesamte Logik läuft in `LateUpdate()`, damit sie nach der Motor-Simulation ausgeführt wird:

```
1. currentY = _motor.TransientPosition.y
2. deltaY = currentY - _previousMotorY
3. _previousMotorY = currentY

// Guard: Kein Model zugewiesen
4. if _modelTransform == null → return

// Teleport-Check: Zu großer Sprung → kein Smoothing
5. if Mathf.Abs(deltaY) > _maxStepDelta:
     _smoothOffset = 0
     _smoothVelocity = 0
     → Apply & Return

// Airborne-Check: In der Luft → Offset sofort auflösen
6. if _onlyWhenGrounded && !_locomotion.IsGrounded:
     _smoothOffset = 0
     _smoothVelocity = 0
     → Apply & Return

// Landing-Check: Gerade gelandet → kein Offset aufbauen
7. if _motor.JustLanded:
     _smoothOffset = 0
     _smoothVelocity = 0
     → Apply & Return

// Step-Up erkannt: Offset aufbauen
8. if Mathf.Abs(deltaY) > 0.001f:
     _smoothOffset -= deltaY

// Offset über Zeit zu 0 auflösen
9. _smoothOffset = Mathf.SmoothDamp(_smoothOffset, 0f, ref _smoothVelocity, _smoothTime)

// Snap bei Minimal-Offset
10. if Mathf.Abs(_smoothOffset) < 0.001f:
      _smoothOffset = 0f

// Apply
11. _modelTransform.localPosition = new Vector3(0f, _smoothOffset, 0f)
```

**Wichtige Abweichung von der Spec:** Schritt 7 (Landing-Check) ist als Edge Case in der Spec beschrieben (Abschnitt "Edge Cases → 4. Landing nach Fall") und muss explizit implementiert werden. `JustLanded` ist auf dem `CharacterMotor` verfügbar.

### Apply-Helper

Der Apply-Schritt kommt mehrfach vor (nach Teleport-Check, Airborne-Check, Landing-Check, und am Ende). Extrahiere eine private Methode:

```csharp
private void ApplyOffset()
{
    _modelTransform.localPosition = new Vector3(0f, _smoothOffset, 0f);
}
```

---

## Verifikation

- [ ] Datei erstellt unter `Runtime/Core/Visual/GroundingSmoother.cs`
- [ ] Namespace `Wiesenwischer.GameKit.CharacterController.Core.Visual`
- [ ] `[RequireComponent(typeof(CharacterMotor))]` vorhanden
- [ ] Alle 4 serialisierten Felder mit `[Header]`, `[Tooltip]`, `[SerializeField]`
- [ ] `Awake()` cached Motor + Locomotion
- [ ] `OnEnable()` initialisiert previousY + resettet Offset
- [ ] `LateUpdate()` implementiert den vollständigen Algorithmus (11 Schritte)
- [ ] Kein GC-Alloc (kein `new` außer `Vector3`-struct)
- [ ] Kompiliert fehlerfrei

---

## Nächster Schritt

→ [20.2 Unit Tests](20.2-unit-tests.md)
