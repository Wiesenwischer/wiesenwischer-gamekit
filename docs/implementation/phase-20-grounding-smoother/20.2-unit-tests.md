# 20.2 Unit Tests für GroundingSmoother

> **Branch:** `feat/grounding-smoother-component` (gleicher Branch wie 20.1)
> **Commit:** `test(phase-20): 20.2 GroundingSmoother Tests`

---

## Ziel

Unit Tests für die GroundingSmoother-Logik. Da `SmoothDamp` und `LateUpdate` Unity-abhängig sind, testen wir die Kern-Logik über eine **testbare Methode** oder extrahierte Logik.

---

## Dateien

| Aktion | Pfad |
|--------|------|
| Erstellen | `Packages/Wiesenwischer.GameKit.CharacterController.Core/Tests/Runtime/Visual/GroundingSmootherTests.cs` |

---

## Test-Strategie

Der GroundingSmoother ist eine MonoBehaviour mit Unity-Abhängigkeiten (`SmoothDamp`, `Transform.localPosition`). Zwei Ansätze sind möglich:

### Ansatz A: Testbare Kern-Methode extrahieren (Empfohlen)

Eine `internal` Methode `CalculateOffset` extrahieren, die den reinen Algorithmus enthält (ohne Unity-Transform-Zugriffe). Diese kann mit `[InternalsVisibleTo]` getestet werden.

```csharp
// In GroundingSmoother.cs
internal struct SmootherState
{
    public float SmoothOffset;
    public float SmoothVelocity;
}

internal static SmootherState CalculateOffset(
    float deltaY,
    bool isGrounded,
    bool justLanded,
    float maxStepDelta,
    bool onlyWhenGrounded,
    float smoothTime,
    SmootherState state,
    float deltaTime)
{
    // Teleport-Check
    if (Mathf.Abs(deltaY) > maxStepDelta)
        return new SmootherState { SmoothOffset = 0f, SmoothVelocity = 0f };

    // Airborne-Check
    if (onlyWhenGrounded && !isGrounded)
        return new SmootherState { SmoothOffset = 0f, SmoothVelocity = 0f };

    // Landing-Check
    if (justLanded)
        return new SmootherState { SmoothOffset = 0f, SmoothVelocity = 0f };

    // Step-Up: Offset aufbauen
    if (Mathf.Abs(deltaY) > 0.001f)
        state.SmoothOffset -= deltaY;

    // SmoothDamp
    state.SmoothOffset = Mathf.SmoothDamp(
        state.SmoothOffset, 0f, ref state.SmoothVelocity, smoothTime, Mathf.Infinity, deltaTime);

    // Snap
    if (Mathf.Abs(state.SmoothOffset) < 0.001f)
    {
        state.SmoothOffset = 0f;
        state.SmoothVelocity = 0f;
    }

    return state;
}
```

**InternalsVisibleTo** hinzufügen in der Assembly Definition oder via `AssemblyInfo.cs`:
```csharp
// Runtime/AssemblyInfo.cs (falls noch nicht vorhanden)
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo(
    "Wiesenwischer.GameKit.CharacterController.Core.Tests.Runtime")]
```

### Ansatz B: PlayMode Tests mit echtem GameObject

Falls Ansatz A zu viel Refactoring erfordert, können PlayMode-Tests mit `new GameObject()` + `AddComponent<GroundingSmoother>()` verwendet werden. Dies ist allerdings langsamer und fragiler.

**Empfehlung:** Ansatz A — testbare Kern-Methode.

---

## Test-Fälle

### Namespace & Setup

```csharp
using NUnit.Framework;
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core.Visual;
using static Wiesenwischer.GameKit.CharacterController.Core.Visual.GroundingSmoother;

namespace Wiesenwischer.GameKit.CharacterController.Core.Tests.Visual
{
    [TestFixture]
    public class GroundingSmootherTests
    {
        private const float DefaultSmoothTime = 0.075f;
        private const float DefaultMaxStepDelta = 0.5f;
        private const float DeltaTime = 1f / 60f;

        private SmootherState _state;

        [SetUp]
        public void SetUp()
        {
            _state = new SmootherState();
        }
    }
}
```

### 1. Step-Up Detection

```
[Test] StepUp_BuildsNegativeOffset
  deltaY = 0.15 (Step hoch), isGrounded = true, justLanded = false
  → SmoothOffset < 0 (Model wird temporär nach unten versetzt)

[Test] StepDown_BuildsPositiveOffset
  deltaY = -0.15 (Step runter), isGrounded = true, justLanded = false
  → SmoothOffset > 0 (Model wird temporär nach oben versetzt)

[Test] SmallDelta_NoOffset
  deltaY = 0.0005 (unter Threshold), isGrounded = true
  → SmoothOffset == 0 (kein Offset bei Micro-Deltas)
```

### 2. Smoothing-Auflösung

```
[Test] Offset_ResolvesToZero_OverTime
  Wiederholtes Aufrufen mit deltaY = 0
  → SmoothOffset nähert sich 0 an

[Test] Offset_SnapsToZero_WhenBelowThreshold
  State mit sehr kleinem SmoothOffset (0.0005)
  → SmoothOffset wird exakt 0 (kein ewiges Micro-Smoothing)
```

### 3. Teleport-Check

```
[Test] LargeDelta_ResetsOffset_Teleport
  deltaY = 2.0 (über maxStepDelta), isGrounded = true
  → SmoothOffset == 0, SmoothVelocity == 0

[Test] NegativeLargeDelta_ResetsOffset_Teleport
  deltaY = -2.0
  → SmoothOffset == 0
```

### 4. Airborne-Check

```
[Test] Airborne_ResetsOffset
  deltaY = 0.1, isGrounded = false, onlyWhenGrounded = true
  → SmoothOffset == 0

[Test] Airborne_KeepsOffset_WhenOnlyWhenGroundedFalse
  deltaY = 0.1, isGrounded = false, onlyWhenGrounded = false
  → SmoothOffset != 0 (Smoothing auch in der Luft)
```

### 5. Landing-Check

```
[Test] JustLanded_ResetsOffset
  state mit SmoothOffset = -0.1, justLanded = true
  → SmoothOffset == 0 (kein falscher Offset nach Landing)
```

### 6. Slopes (kein Offset)

```
[Test] ContinuousSmallDelta_MinimalOffset
  Viele Aufrufe mit deltaY = 0.0005 (Slope-typisch bei 60fps)
  → SmoothOffset bleibt ~0 (kein sichtbarer Effekt bei Slopes)
```

---

## Verifikation

- [ ] Testdatei erstellt unter `Tests/Runtime/Visual/GroundingSmootherTests.cs`
- [ ] Namespace `Wiesenwischer.GameKit.CharacterController.Core.Tests.Visual`
- [ ] `InternalsVisibleTo` konfiguriert (AssemblyInfo.cs oder asmdef)
- [ ] Alle 10+ Tests implementiert und grün
- [ ] Tests decken ab: Step-Up, Step-Down, Teleport, Airborne, Landing, Slopes, Snap
- [ ] Keine Unity-Szene nötig für die Tests (reine Logik-Tests)

---

## Nächster Schritt

→ [20.3 Prefab-Integration](20.3-prefab-integration.md)
