# 28.5 CinemachineDriver (optional)

> **Commit:** `feat(phase-28): 28.5 CinemachineDriver — optionale Rendering-Schicht`
> **Branch:** `feat/cinemachine-driver` (vom Integration-Branch)

---

## Ziel

Einen optionalen **CinemachineDriver** implementieren, der den berechneten CameraState auf eine Cinemachine VirtualCamera überträgt. Cinemachine dient als **reine Rendering-Schicht** — keine Gameplay-Logik in Cinemachine.

**Wichtig:** Das Camera-System funktioniert vollständig **ohne** CinemachineDriver. Der Driver ist ein optionales Add-On für Teams, die Cinemachine-Features wie Blending, Noise oder PostProcessing nutzen wollen.

---

## Architektur

```
CameraBrain
  ↓ berechnet CameraState
PivotRig
  ↓ setzt Transform-Hierarchie
CinemachineDriver (optional)
  ↓ kopiert Position/Rotation/FOV
CinemachineVirtualCamera
  ↓ Cinemachine Pipeline (Noise, PostFX, Blends)
CinemachineBrain
  ↓ setzt finale Kamera
Unity Camera
```

### Was der CinemachineDriver tut

1. Liest die **finale Kamera-Position** aus dem PivotRig
2. Liest die **finale Rotation** aus dem PivotRig
3. Liest **FOV** aus CameraState
4. Setzt diese Werte auf eine CinemachineVirtualCamera
5. Cinemachine kann dann zusätzliche Effekte drauflegen (Noise, Blending)

### Was der CinemachineDriver NICHT tut

- Keine Orbit-Berechnung
- Keine Follow-Logik
- Keine Collision
- Keine Gameplay-Entscheidungen

---

## Neue Datei

### CinemachineDriver.cs

**Pfad:** `Packages/Wiesenwischer.GameKit.Camera.Core/Runtime/Rendering/CinemachineDriver.cs`

```csharp
using UnityEngine;
#if CINEMACHINE_AVAILABLE
using Cinemachine;
#endif

namespace Wiesenwischer.GameKit.Camera
{
    /// <summary>
    /// Optionale Rendering-Schicht: Überträgt den CameraState auf eine Cinemachine VirtualCamera.
    /// Cinemachine wird nur zum Rendern verwendet — keine Gameplay-Logik.
    /// Funktioniert nur wenn Cinemachine im Projekt installiert ist.
    /// </summary>
    public class CinemachineDriver : MonoBehaviour
    {
        [Header("References")]
        [Tooltip("CameraBrain von dem der State gelesen wird")]
        [SerializeField] private CameraBrain _brain;

        [Tooltip("PivotRig für die finale Transform-Position")]
        [SerializeField] private PivotRig _pivotRig;

#if CINEMACHINE_AVAILABLE
        [Header("Cinemachine")]
        [Tooltip("Cinemachine VirtualCamera die gesteuert wird")]
        [SerializeField] private CinemachineVirtualCamera _virtualCamera;

        [Tooltip("Sync-Modus")]
        [SerializeField] private SyncMode _syncMode = SyncMode.PositionRotationFov;

        public enum SyncMode
        {
            /// <summary>Nur Position und Rotation.</summary>
            PositionRotation,
            /// <summary>Position, Rotation und FOV.</summary>
            PositionRotationFov
        }

        private void LateUpdate()
        {
            if (_virtualCamera == null || _pivotRig == null || _brain == null)
                return;

            // Position und Rotation vom PivotRig übernehmen
            var cameraTransform = _virtualCamera.transform;
            cameraTransform.position = _pivotRig.GetCameraWorldPosition();
            cameraTransform.rotation = _pivotRig.GetCameraWorldRotation();

            // FOV synchronisieren
            if (_syncMode == SyncMode.PositionRotationFov)
            {
                _virtualCamera.m_Lens.FieldOfView = _brain.State.Fov;
            }
        }

        private void OnValidate()
        {
            if (_brain == null)
                _brain = GetComponentInParent<CameraBrain>();
            if (_pivotRig == null)
                _pivotRig = GetComponentInParent<PivotRig>();
        }
#else
        private void Awake()
        {
            Debug.LogWarning(
                "[CinemachineDriver] Cinemachine ist nicht installiert. " +
                "Der Driver hat keine Funktion. " +
                "Installiere 'com.unity.cinemachine' über den Package Manager.");
            enabled = false;
        }
#endif
    }
}
```

---

## Cinemachine Define-Symbol

Das `CINEMACHINE_AVAILABLE` Symbol muss automatisch erkannt werden. Unity Cinemachine 2.x definiert automatisch ein Scripting Define Symbol. Zwei Optionen:

### Option A: Version Defines in Assembly Definition (empfohlen)

In der `Wiesenwischer.GameKit.Camera.Core.Runtime.asmdef`:

```json
{
    "versionDefines": [
        {
            "name": "com.unity.cinemachine",
            "expression": "2.0.0",
            "define": "CINEMACHINE_AVAILABLE"
        }
    ]
}
```

Dies definiert `CINEMACHINE_AVAILABLE` automatisch, wenn Cinemachine >= 2.0.0 installiert ist.

### Option B: Manuelles Define

In Unity: `Project Settings → Player → Scripting Define Symbols`:
```
CINEMACHINE_AVAILABLE
```

**Empfehlung:** Option A (versionDefines) ist sauberer und automatisch.

---

## Anweisungen

### Schritt 1: Rendering-Ordner erstellen

1. Erstelle `Packages/Wiesenwischer.GameKit.Camera.Core/Runtime/Rendering/`
2. Dies ist der neue Ordner für optionale Rendering-Komponenten

### Schritt 2: CinemachineDriver.cs erstellen

1. Erstelle die Datei wie oben beschrieben
2. Nutze `#if CINEMACHINE_AVAILABLE` für alle Cinemachine-Abhängigkeiten
3. Ohne Cinemachine: Warning-Log und Selbst-Deaktivierung

### Schritt 3: Assembly Definition aktualisieren

1. Öffne `Wiesenwischer.GameKit.Camera.Core.Runtime.asmdef`
2. Füge `versionDefines` für Cinemachine hinzu
3. **NICHT** Cinemachine als harte Referenz hinzufügen — es bleibt optional

### Schritt 4: Verifikation

1. **Mit Cinemachine:** Component hinzufügen, VirtualCamera zuweisen, testen dass Position/Rotation/FOV synchronisiert werden
2. **Ohne Cinemachine:** Sicherstellen dass das Projekt kompiliert und CinemachineDriver sich deaktiviert

---

## Verifikations-Checkliste

- [ ] `CinemachineDriver.cs` existiert in `Camera.Core/Runtime/Rendering/`
- [ ] Projekt kompiliert mit UND ohne Cinemachine
- [ ] `versionDefines` in Assembly Definition korrekt
- [ ] Mit Cinemachine: VirtualCamera wird synchronisiert
- [ ] Ohne Cinemachine: Warning-Log erscheint, Component deaktiviert sich
- [ ] CinemachineDriver erzeugt keine harte Abhängigkeit auf Cinemachine

---

## Erwartete Dateien nach diesem Schritt

```
Packages/Wiesenwischer.GameKit.Camera.Core/
├── Runtime/
│   ├── Brain/
│   │   └── CameraBrain.cs          (unverändert, wird in 28.6 erweitert)
│   ├── Core/
│   │   └── ...                      (aus 28.1 + 28.2)
│   ├── Rendering/
│   │   └── CinemachineDriver.cs    (NEU)
│   └── ...
└── ...
```

---

## Nächster Schritt

→ [28.6 CameraBrain Integration + Editor Update](28.6-brain-integration-editor.md)
