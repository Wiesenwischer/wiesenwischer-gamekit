# 28.6 CameraBrain Integration + Editor Update

> **Commit:** `feat(phase-28): 28.6 CameraBrain Intent Resolution + Editor Update`
> **Branch:** `feat/camera-brain-intents` (vom Integration-Branch)

---

## Ziel

Den **CameraBrain** um die Intent-Resolution und Preset-Anwendung erweitern. Den **CameraSetupEditor** aktualisieren, um die neuen Behaviours und den optionalen CinemachineDriver beim Setup hinzuzufügen.

---

## CameraBrain-Erweiterungen

### Neue Funktionalität

1. **Intent Management:** PushIntent / RemoveIntent / ClearIntents
2. **Intent Resolution:** Intents sortiert nach Priorität VOR den Behaviours anwenden
3. **SetPreset():** Preset-Werte auf alle ICameraPresetReceiver-Behaviours anwenden
4. **CameraContext:** Neue Felder (CharacterVelocity, CharacterForward) pro Frame befüllen

### Erweiterte LateUpdate-Reihenfolge

```
CameraBrain.LateUpdate()
  1. Input über Pipeline verarbeiten
  2. Anchor aktualisieren
  3. Context zusammenbauen
     + CharacterVelocity aus FollowTarget lesen
     + CharacterForward aus FollowTarget lesen
  4. Intents nach Priorität sortieren + anwenden       ← NEU
  5. Behaviours iterieren (wie bisher)
  6. PivotRig.ApplyState()
  7. FOV setzen
```

### CameraBrain Änderungen (Pseudocode)

**Wichtig:** Diese Änderungen bauen auf dem **refactored CameraBrain aus Phase 27** auf (27.5). Der Phase-27-Brain hat keine eingebettete Orbit/Zoom/Collision-Logik mehr — alles läuft über ICameraBehaviour[].

```csharp
public class CameraBrain : MonoBehaviour
{
    // --- Bestehende Felder ---
    [SerializeField] private CameraAnchor _anchor;
    [SerializeField] private CameraInputPipeline _inputPipeline;
    [SerializeField] private UnityEngine.Camera _camera;

    // --- Phase 28: Neue Felder ---
    [Header("Preset")]
    [Tooltip("Aktives Camera-Preset (optional)")]
    [SerializeField] private CameraPreset _activePreset;

    private PivotRig _rig;
    private CameraState _state;
    private CameraContext _context;
    private ICameraBehaviour[] _behaviours;
    private readonly List<ICameraIntent> _intents = new List<ICameraIntent>();

    // --- Neue öffentliche API ---

    /// <summary>
    /// Registriert einen Intent. Wird bis zum Entfernen jeden Frame angewendet.
    /// </summary>
    public void PushIntent(ICameraIntent intent)
    {
        if (!_intents.Contains(intent))
        {
            _intents.Add(intent);
            _intents.Sort((a, b) => a.Priority.CompareTo(b.Priority));
        }
    }

    /// <summary>
    /// Entfernt einen zuvor registrierten Intent.
    /// </summary>
    public void RemoveIntent(ICameraIntent intent)
    {
        _intents.Remove(intent);
    }

    /// <summary>
    /// Entfernt alle aktiven Intents.
    /// </summary>
    public void ClearIntents()
    {
        _intents.Clear();
    }

    /// <summary>
    /// Wendet ein Preset auf alle ICameraPresetReceiver-Behaviours an.
    /// </summary>
    public void SetPreset(CameraPreset preset)
    {
        _activePreset = preset;
        if (preset == null) return;

        _state.Fov = preset.DefaultFov;

        foreach (var behaviour in _behaviours)
        {
            if (behaviour is ICameraPresetReceiver receiver)
                receiver.ApplyPreset(preset);
        }
    }

    // --- Angepasste LateUpdate ---

    private void Awake()
    {
        _rig = GetComponent<PivotRig>();
        _rig.EnsureHierarchy();
        _context = new CameraContext();
        _state = CameraState.Default;

        RefreshBehaviours();

        // Initiales Preset anwenden
        if (_activePreset != null)
            SetPreset(_activePreset);

        if (_camera == null)
            _camera = GetComponentInChildren<UnityEngine.Camera>();
    }

    /// <summary>Behaviours neu vom GameObject einlesen.</summary>
    public void RefreshBehaviours()
    {
        _behaviours = GetComponents<ICameraBehaviour>();
    }

    private void LateUpdate()
    {
        float dt = Time.deltaTime;

        // 1. Input
        CameraInputState input = default;
        if (_inputPipeline != null)
            input = _inputPipeline.ProcessInput(dt);

        // 2. Anchor
        if (_anchor != null)
            _anchor.UpdateAnchor(dt);

        // 3. Context zusammenbauen
        _context.Input = input;
        _context.AnchorPosition = _anchor != null ? _anchor.AnchorPosition : transform.position;
        _context.DeltaTime = dt;

        // Phase 28: CharacterVelocity + CharacterForward befüllen
        PopulateCharacterContext();

        // 4. Intents anwenden (nach Priorität, aufsteigend)
        foreach (var intent in _intents)
        {
            if (intent.IsActive)
                intent.Apply(ref _state, _context);
        }

        // 5. Behaviours iterieren
        foreach (var behaviour in _behaviours)
        {
            if (behaviour.IsActive)
                behaviour.UpdateState(ref _state, _context);
        }

        // 6. Apply
        _rig.ApplyState(_state, _context.AnchorPosition);

        // 7. FOV
        if (_camera != null)
            _camera.fieldOfView = _state.Fov;
    }

    private void PopulateCharacterContext()
    {
        if (_anchor == null || _anchor.FollowTarget == null)
        {
            _context.CharacterVelocity = Vector3.zero;
            _context.CharacterForward = Vector3.forward;
            return;
        }

        Transform target = _anchor.FollowTarget;
        _context.CharacterForward = target.forward;

        // Velocity aus CharacterController lesen (falls vorhanden)
        var cc = target.GetComponent<CharacterController>();
        if (cc != null)
        {
            _context.CharacterVelocity = cc.velocity;
        }
        else
        {
            // Fallback: Rigidbody
            var rb = target.GetComponent<Rigidbody>();
            _context.CharacterVelocity = rb != null ? rb.linearVelocity : Vector3.zero;
        }
    }

    // SnapBehindTarget erweitert: auch DynamicOrbitCenter snappen
    public void SnapBehindTarget()
    {
        if (_anchor != null && _anchor.FollowTarget != null)
        {
            _anchor.SnapToTarget();
            _state.Yaw = _anchor.FollowTarget.eulerAngles.y;
            _state.Pitch = 0f;

            // DynamicOrbitCenter snappen
            foreach (var behaviour in _behaviours)
            {
                if (behaviour is Behaviours.DynamicOrbitCenterBehaviour dynamicOrbit)
                    dynamicOrbit.Snap();
            }

            _rig.ApplyState(_state, _anchor.AnchorPosition);
        }
    }
}
```

**Hinweis zu `PopulateCharacterContext()`:** Die Methode liest Velocity aus `CharacterController.velocity`. Falls das FollowTarget keinen CharacterController hat (z.B. bei Tests), wird ein Rigidbody-Fallback oder Vector3.zero verwendet. Die `GetComponent`-Aufrufe könnten gecacht werden für Performance — das kann als spätere Optimierung erfolgen.

---

## CameraSetupEditor-Erweiterungen

### Aktualisierter Setup-Flow

```
1. Player finden
2. Main Camera finden/erstellen
3. PivotRig + CameraAnchor + CameraInputPipeline (wie bisher)
4. Standard-Behaviours hinzufügen (aus Phase 27)
5. Neue Behaviours hinzufügen:                                ← NEU
   - DynamicOrbitCenterBehaviour (deaktiviert per Default)
   - SoftTargetingBehaviour (deaktiviert per Default)
6. CinemachineDriver (optional, nur wenn Cinemachine vorhanden) ← NEU
7. Preset zuweisen (falls vorhanden)                            ← NEU
8. CameraBrain konfigurieren
9. Snap hinter Target
```

### Neuer Menü-Eintrag (optional)

```csharp
[MenuItem("Wiesenwischer/GameKit/Camera/Apply Camera Preset", false, 110)]
public static void ApplyPresetMenu()
{
    // Dialog: Preset-Asset auswählen
    // CameraBrain finden und SetPreset() aufrufen
}
```

### Anpassungen im bestehenden Setup

```csharp
// Nach den Phase-27-Behaviours:

// DynamicOrbitCenter (deaktiviert per Default)
var dynamicOrbit = cameraRoot.GetComponent<DynamicOrbitCenterBehaviour>();
if (dynamicOrbit == null)
{
    dynamicOrbit = cameraRoot.AddComponent<DynamicOrbitCenterBehaviour>();
    dynamicOrbit.enabled = false;
    Debug.Log("[CameraSetup] DynamicOrbitCenterBehaviour hinzugefügt (deaktiviert).");
}

// SoftTargeting (deaktiviert per Default)
var softTargeting = cameraRoot.GetComponent<SoftTargetingBehaviour>();
if (softTargeting == null)
{
    softTargeting = cameraRoot.AddComponent<SoftTargetingBehaviour>();
    softTargeting.enabled = false;
    Debug.Log("[CameraSetup] SoftTargetingBehaviour hinzugefügt (deaktiviert).");
}

// CinemachineDriver (nur wenn Cinemachine vorhanden)
#if CINEMACHINE_AVAILABLE
var cinemachineDriver = cameraRoot.GetComponent<CinemachineDriver>();
if (cinemachineDriver == null)
{
    cinemachineDriver = cameraRoot.AddComponent<CinemachineDriver>();
    cinemachineDriver.enabled = false;
    Debug.Log("[CameraSetup] CinemachineDriver hinzugefügt (deaktiviert).");
}
#endif

// Preset zuweisen (suche in Assets)
var preset = FindDefaultPreset();
if (preset != null)
{
    brain.SetPreset(preset);
    Debug.Log($"[CameraSetup] Preset '{preset.name}' angewendet.");
}
```

---

## Component-Reihenfolge im Inspector

Die Reihenfolge der Komponenten am Camera-GameObject bestimmt die Evaluierungsreihenfolge:

```
[PivotRig]
[CameraAnchor]
[CameraInputPipeline]
[CameraBrain]
--- Behaviours (in dieser Reihenfolge): ---
[DynamicOrbitCenterBehaviour]    ← Muss zuerst (modifiziert AnchorPosition)
[OrbitBehaviour]
[RecenterBehaviour]
[ZoomBehaviour]
[ShoulderOffsetBehaviour]
[SoftTargetingBehaviour]
[CollisionBehaviour]
[InertiaBehaviour]
--- Optional: ---
[CinemachineDriver]
```

**Der CameraSetupEditor muss die Behaviours in dieser Reihenfolge hinzufügen.**

---

## Anweisungen

### Schritt 1: CameraBrain erweitern

1. Intent-Management: `_intents` Liste, `PushIntent`, `RemoveIntent`, `ClearIntents`
2. `SetPreset()` implementieren
3. `PopulateCharacterContext()` implementieren
4. LateUpdate anpassen: Intents vor Behaviours
5. `SnapBehindTarget()` erweitern: DynamicOrbitCenter.Snap()
6. `_activePreset` SerializeField + Awake-Initialisierung

### Schritt 2: CameraSetupEditor erweitern

1. Neue Behaviours (DynamicOrbitCenter, SoftTargeting) hinzufügen
2. CinemachineDriver optional hinzufügen
3. Component-Reihenfolge sicherstellen
4. Preset-Suche und -Zuweisung

### Schritt 3: CameraCoreConfig prüfen

Nach Phase 27 + 28 ersetzt CameraPreset effektiv die CameraCoreConfig. Zwei Optionen:
- **Option A (empfohlen):** CameraCoreConfig als Legacy behalten, CameraBrain nutzt Preset wenn vorhanden
- **Option B:** CameraCoreConfig entfernen und durch CameraPreset ersetzen

**Empfehlung:** Option A — CameraCoreConfig bleibt als Fallback, CameraPreset überschreibt bei Zuweisung.

---

## Verifikations-Checkliste

- [ ] CameraBrain hat `PushIntent()`, `RemoveIntent()`, `ClearIntents()`
- [ ] CameraBrain hat `SetPreset(CameraPreset)`
- [ ] Intents werden VOR Behaviours in LateUpdate angewendet
- [ ] CameraContext wird mit CharacterVelocity + CharacterForward befüllt
- [ ] `_activePreset` wird in Awake angewendet
- [ ] CameraSetupEditor fügt neue Behaviours hinzu
- [ ] CinemachineDriver wird nur hinzugefügt wenn Cinemachine vorhanden
- [ ] Component-Reihenfolge im Inspector ist korrekt
- [ ] Projekt kompiliert fehlerfrei
- [ ] Bestehende Kamera-Funktionalität ist unverändert (ohne Preset/Intents)

---

## Erwartete Dateien nach diesem Schritt

```
Packages/Wiesenwischer.GameKit.Camera.Core/
├── Runtime/
│   └── Brain/
│       └── CameraBrain.cs           (ERWEITERT)
├── Editor/
│   └── CameraSetupEditor.cs         (ERWEITERT)
```

---

## Nächster Schritt

→ [28.7 Unit Tests](28.7-unit-tests.md)
