# 28.4 DynamicOrbitCenter + Soft Targeting Behaviours

> **Commit:** `feat(phase-28): 28.4 DynamicOrbitCenter + Soft Targeting Behaviours`
> **Branch:** `feat/camera-dynamic-orbit` (vom Integration-Branch)

---

## Ziel

Zwei neue **ICameraBehaviour-Implementierungen** im Camera.Behaviours Package:

1. **DynamicOrbitCenterBehaviour** — verschiebt den Orbit-Pivot dynamisch basierend auf Character-Zustand (Idle vs. Movement vs. Combat)
2. **SoftTargetingBehaviour** — additive Bias-Rotation Richtung Movement-Direction und/oder LookTarget

Beide nutzen die in 28.1 erweiterten CameraContext-Felder (`CharacterVelocity`, `CharacterForward`).

---

## Architektur

### DynamicOrbitCenter

Statt immer um die Character-Position zu orbiten, wird der Orbit-Pivot kontextabhängig verschoben:

| Zustand | Orbit Center | Effekt |
|---------|-------------|--------|
| **Idle** | Character Position | Standard |
| **Movement** | Character + MoveDir × ForwardBias | Kamera schaut voraus |
| **Combat** (LookTarget) | Midpoint(Character, Target) | Target im Blickfeld |

**Implementierung:** Das Behaviour modifiziert **nicht** CameraState direkt, sondern `CameraContext.AnchorPosition`. Damit wirkt die Verschiebung auf alle nachfolgenden Behaviours (Orbit, Collision, etc.).

**Wichtig:** DynamicOrbitCenter muss **vor** den anderen Behaviours im Stack stehen, da es die Anchor-Position verschiebt.

```
Anchor Position (stabilisiert)
    ↓
DynamicOrbitCenterBehaviour → verschiebt Anchor
    ↓
OrbitBehaviour (orbitet um verschobene Position)
    ↓
CollisionBehaviour (prüft von verschobener Position)
```

### Soft Targeting

Additive Bias-Rotation — die Kamera wird sanft in Richtung eines Ziels gedreht, ohne den Player-Input zu überschreiben:

```
FinalYaw = InputYaw + SoftBias
```

Bias-Quellen:
- **Movement Forward Bias:** Leichtes Vorausschauen in Bewegungsrichtung
- **Target Bias:** Sanftes Hinschauen zum LookTarget (Enemy, NPC)

Die Bias-Werte werden per SmoothDamp interpoliert, sodass keine abrupten Kamera-Sprünge entstehen.

---

## Neue Dateien

### 1. DynamicOrbitCenterBehaviour.cs

**Pfad:** `Packages/Wiesenwischer.GameKit.Camera.Behaviours/Runtime/DynamicOrbitCenterBehaviour.cs`

```csharp
using UnityEngine;

namespace Wiesenwischer.GameKit.Camera.Behaviours
{
    /// <summary>
    /// Verschiebt den Orbit-Pivot dynamisch basierend auf Character-Zustand.
    /// Idle: Character Position. Movement: Forward Bias. Combat: Target Midpoint.
    /// </summary>
    public class DynamicOrbitCenterBehaviour : MonoBehaviour, ICameraBehaviour, ICameraPresetReceiver
    {
        [Header("Config")]
        [Tooltip("Forward Bias in Metern bei Bewegung")]
        [SerializeField] private float _forwardBias = 0.5f;

        [Tooltip("Smooth-Zeit für Orbit-Center Verschiebung")]
        [SerializeField] private float _damping = 0.1f;

        [Tooltip("Minimale Character-Geschwindigkeit für Forward Bias")]
        [SerializeField] private float _minSpeed = 0.5f;

        [Tooltip("Anteil der Strecke zum Target für Combat-Midpoint (0=Player, 1=Target)")]
        [SerializeField] [Range(0f, 0.5f)] private float _targetMidpointRatio = 0.3f;

        private Vector3 _currentOffset;
        private Vector3 _offsetVelocity;

        public bool IsActive => enabled;

        public void UpdateState(ref CameraState state, CameraContext ctx)
        {
            Vector3 targetOffset = Vector3.zero;

            // Combat-Modus: Orbit-Center zwischen Player und Target
            if (ctx.LookTarget != null)
            {
                Vector3 toTarget = ctx.LookTarget.position - ctx.AnchorPosition;
                targetOffset = toTarget * _targetMidpointRatio;
            }
            // Movement-Modus: Forward Bias
            else if (ctx.CharacterVelocity.sqrMagnitude > _minSpeed * _minSpeed)
            {
                Vector3 moveDir = ctx.CharacterVelocity;
                moveDir.y = 0f;
                if (moveDir.sqrMagnitude > 0.001f)
                    targetOffset = moveDir.normalized * _forwardBias;
            }
            // Idle: Kein Offset

            // Smooth Transition
            _currentOffset = Vector3.SmoothDamp(
                _currentOffset, targetOffset,
                ref _offsetVelocity, _damping,
                Mathf.Infinity, ctx.DeltaTime);

            // AnchorPosition verschieben
            ctx.AnchorPosition += _currentOffset;
        }

        /// <summary>Snap auf Target-Position (kein Smoothing).</summary>
        public void Snap()
        {
            _currentOffset = Vector3.zero;
            _offsetVelocity = Vector3.zero;
        }

        public void ApplyPreset(CameraPreset preset)
        {
            enabled = preset.DynamicOrbitEnabled;
            _forwardBias = preset.ForwardBias;
            _damping = preset.OrbitCenterDamping;
        }
    }
}
```

**Hinweis:** Dieses Behaviour modifiziert `ctx.AnchorPosition` direkt (nicht `ref state`). Das ist eine Besonderheit — die meisten Behaviours modifizieren nur den CameraState. Der CameraBrain muss sicherstellen, dass DynamicOrbitCenter **vor** allen anderen Behaviours evaluiert wird.

### 2. SoftTargetingBehaviour.cs

**Pfad:** `Packages/Wiesenwischer.GameKit.Camera.Behaviours/Runtime/SoftTargetingBehaviour.cs`

```csharp
using UnityEngine;

namespace Wiesenwischer.GameKit.Camera.Behaviours
{
    /// <summary>
    /// Additive Bias-Rotation Richtung Movement und/oder LookTarget.
    /// Überschreibt nicht den Player-Input, sondern addiert sanft.
    /// </summary>
    public class SoftTargetingBehaviour : MonoBehaviour, ICameraBehaviour, ICameraPresetReceiver
    {
        [Header("Movement Bias")]
        [Tooltip("Stärke des Forward-Bias in Grad")]
        [SerializeField] private float _movementBiasStrength = 5f;

        [Header("Target Bias")]
        [Tooltip("Stärke des Target-Bias in Grad")]
        [SerializeField] private float _targetBiasStrength = 15f;

        [Tooltip("Maximaler Erfassungsradius für Soft Target")]
        [SerializeField] private float _targetRange = 20f;

        [Header("Smoothing")]
        [Tooltip("Smooth-Zeit für Bias-Übergänge")]
        [SerializeField] private float _damping = 0.15f;

        private float _currentYawBias;
        private float _currentPitchBias;
        private float _yawBiasVelocity;
        private float _pitchBiasVelocity;

        public bool IsActive => enabled;

        public void UpdateState(ref CameraState state, CameraContext ctx)
        {
            float targetYawBias = 0f;
            float targetPitchBias = 0f;

            // 1. Target Bias (höhere Priorität)
            if (ctx.LookTarget != null && _targetBiasStrength > 0f)
            {
                Vector3 toTarget = ctx.LookTarget.position - ctx.AnchorPosition;

                if (toTarget.sqrMagnitude <= _targetRange * _targetRange
                    && toTarget.sqrMagnitude > 0.01f)
                {
                    // Horizontaler Winkel zum Target
                    Vector3 currentForward = Quaternion.Euler(0f, state.Yaw, 0f) * Vector3.forward;
                    Vector3 toTargetFlat = new Vector3(toTarget.x, 0f, toTarget.z);

                    if (toTargetFlat.sqrMagnitude > 0.001f)
                    {
                        float angleToTarget = Vector3.SignedAngle(
                            currentForward, toTargetFlat.normalized, Vector3.up);
                        targetYawBias = Mathf.Clamp(
                            angleToTarget, -_targetBiasStrength, _targetBiasStrength);
                    }

                    // Vertikaler Bias zum Target (optional)
                    float verticalAngle = Mathf.Atan2(toTarget.y, toTargetFlat.magnitude)
                                          * Mathf.Rad2Deg;
                    targetPitchBias = Mathf.Clamp(
                        verticalAngle * 0.3f, -10f, 10f);
                }
            }
            // 2. Movement Forward Bias
            else if (ctx.CharacterVelocity.sqrMagnitude > 0.25f
                     && _movementBiasStrength > 0f)
            {
                Vector3 moveDir = new Vector3(
                    ctx.CharacterVelocity.x, 0f, ctx.CharacterVelocity.z);

                if (moveDir.sqrMagnitude > 0.001f)
                {
                    Vector3 currentForward = Quaternion.Euler(0f, state.Yaw, 0f) * Vector3.forward;
                    float angleToMove = Vector3.SignedAngle(
                        currentForward, moveDir.normalized, Vector3.up);
                    targetYawBias = Mathf.Clamp(
                        angleToMove, -_movementBiasStrength, _movementBiasStrength);
                }
            }

            // Smooth Bias
            _currentYawBias = Mathf.SmoothDamp(
                _currentYawBias, targetYawBias,
                ref _yawBiasVelocity, _damping,
                Mathf.Infinity, ctx.DeltaTime);

            _currentPitchBias = Mathf.SmoothDamp(
                _currentPitchBias, targetPitchBias,
                ref _pitchBiasVelocity, _damping,
                Mathf.Infinity, ctx.DeltaTime);

            // Additive Rotation
            state.Yaw += _currentYawBias;
            state.Pitch += _currentPitchBias;
        }

        public void ApplyPreset(CameraPreset preset)
        {
            enabled = preset.SoftTargetingEnabled;
            _movementBiasStrength = preset.MovementBiasStrength;
            _targetBiasStrength = preset.TargetBiasStrength;
            _targetRange = preset.SoftTargetRange;
            _damping = preset.SoftTargetDamping;
        }
    }
}
```

---

## Behaviour-Reihenfolge (aktualisiert)

Nach Phase 28 sieht die vollständige Behaviour-Reihenfolge so aus:

```
1. DynamicOrbitCenterBehaviour  → Anchor-Position verschieben (VOR allen anderen!)
2. OrbitBehaviour               → Yaw/Pitch aus Input
3. RecenterBehaviour            → Auto-Yaw hinter Movement
4. ZoomBehaviour                → Distance aus Zoom-Input
5. ShoulderOffsetBehaviour      → ShoulderOffset setzen
6. SoftTargetingBehaviour       → Additive Yaw/Pitch-Bias
7. CollisionBehaviour           → Distance clampen
8. InertiaBehaviour             → Position-Offset für cinematic lag
```

**Wichtig:** DynamicOrbitCenter muss an Position 1 stehen, da es die AnchorPosition verändert. SoftTargeting sollte nach Orbit/Recenter stehen (addiert auf den berechneten Yaw) und vor Collision (damit die Collision-Prüfung den finalen Winkel kennt).

---

## Anweisungen

### Schritt 1: DynamicOrbitCenterBehaviour erstellen

1. Erstelle `DynamicOrbitCenterBehaviour.cs` im Camera.Behaviours Runtime-Ordner
2. Implementiere wie oben beschrieben
3. Beachte: `ctx.AnchorPosition` wird direkt modifiziert, nicht `ref state`
4. Snap()-Methode für Teleport-Situationen

### Schritt 2: SoftTargetingBehaviour erstellen

1. Erstelle `SoftTargetingBehaviour.cs` im Camera.Behaviours Runtime-Ordner
2. Implementiere Yaw-Bias und Pitch-Bias
3. Target-Bias hat Vorrang vor Movement-Bias (if/else)
4. Alle Bias-Werte werden per SmoothDamp geglättet

### Schritt 3: Camera.Behaviours Assembly aktualisieren

Falls die Assembly Definition aktualisiert werden muss (normalerweise nicht nötig, da neue Dateien im gleichen Ordner/Assembly liegen).

---

## Verifikations-Checkliste

- [ ] `DynamicOrbitCenterBehaviour.cs` kompiliert fehlerfrei
- [ ] `SoftTargetingBehaviour.cs` kompiliert fehlerfrei
- [ ] Beide implementieren `ICameraBehaviour` und `ICameraPresetReceiver`
- [ ] DynamicOrbitCenter: verschiebt ctx.AnchorPosition bei Bewegung
- [ ] DynamicOrbitCenter: Snap() setzt Offset zurück
- [ ] SoftTargeting: addiert Yaw-Bias bei Movement
- [ ] SoftTargeting: addiert Yaw+Pitch-Bias bei LookTarget
- [ ] SoftTargeting: kein Bias wenn kein Target und keine Bewegung
- [ ] Projekt kompiliert fehlerfrei

---

## Erwartete Dateien nach diesem Schritt

```
Packages/Wiesenwischer.GameKit.Camera.Behaviours/Runtime/
├── OrbitBehaviour.cs                   (Phase 27)
├── ZoomBehaviour.cs                    (Phase 27)
├── CollisionBehaviour.cs               (Phase 27)
├── InertiaBehaviour.cs                 (Phase 27)
├── RecenterBehaviour.cs                (Phase 27)
├── ShoulderOffsetBehaviour.cs          (Phase 27)
├── DynamicOrbitCenterBehaviour.cs      (NEU)
└── SoftTargetingBehaviour.cs           (NEU)
```

---

## Nächster Schritt

→ [28.5 CinemachineDriver](28.5-cinemachine-driver.md)
