# 8.3 FootIK Modul

> **Branch:** `feat/ik-foot-lookat`
> **Commit:** `feat(phase-8): 8.3 FootIK Modul`

---

## Ziel

`FootIK` Modul implementieren, das die Füße des Characters an das Terrain anpasst. Auf Stufen, Slopes und unebenen Flächen stehen die Füße korrekt auf dem Boden statt in der Luft zu schweben oder im Boden zu stecken.

---

## Dateien

| Aktion | Pfad |
|--------|------|
| Erstellen | `Packages/Wiesenwischer.GameKit.CharacterController.IK/Runtime/Modules/FootIK.cs` |

---

## Namespace & Ordner

```
Packages/Wiesenwischer.GameKit.CharacterController.IK/
└── Runtime/
    ├── Core/          ← bestehend (Interfaces, IKManager)
    └── Modules/       ← NEU
        └── FootIK.cs
```

**Namespace:** `Wiesenwischer.GameKit.CharacterController.IK.Modules`

---

## Konzept

### Algorithmus (pro Frame)

1. **PrepareIK (LateUpdate):** Raycasts von Fuß-Knochen nach unten ausführen
2. **ProcessIK (OnAnimatorIK):** Fuß-Position und -Rotation per IK anpassen

### Raycast-Strategie

Für jeden Fuß (Left, Right):
1. Ausgangspunkt: Aktuelle Fuß-Knochen-Position (aus Animation)
2. Raycast von `footPos + Vector3.up * raycastHeight` nach `Vector3.down`
3. Raycast-Länge: `raycastHeight + raycastDepth` (über + unter dem Fuß)
4. Hit-Point = neue Fuß-Zielposition
5. Hit-Normal = Fuß-Rotation (Fußsohle liegt auf der Fläche)

### Body Offset

Wenn ein Fuß tiefer stehen muss (z.B. auf einer tieferen Stufe), muss der gesamte Body nach unten versetzt werden, damit der Fuß den Boden erreichen kann — sonst streckt sich das Bein über das IK-Limit.

```
Body Offset = min(leftFootDelta, rightFootDelta)
```

Nur negative Offsets (nach unten) sind sinnvoll — der Body wird abgesenkt, nie angehoben.

---

## Detaillierte Anweisungen

### Klassen-Struktur

```csharp
using UnityEngine;
using Wiesenwischer.GameKit.CharacterController.Core;

namespace Wiesenwischer.GameKit.CharacterController.IK.Modules
{
    /// <summary>
    /// Foot IK Modul: Passt Fuß-Positionen an das Terrain an.
    /// Raycasts pro Fuß ermitteln die Bodenkontaktpunkte,
    /// IK verschiebt die Füße auf den Boden und rotiert die Fußsohlen
    /// entlang der Oberflächen-Normalen.
    /// </summary>
    public class FootIK : MonoBehaviour, IIKModule
    {
        // ... (siehe unten)
    }
}
```

### Serialisierte Felder

| Feld | Typ | Default | Beschreibung |
|------|-----|---------|-------------|
| `_playerController` | PlayerController | — | Für IsGrounded-Check |
| `_weight` | float | 1.0 | IK Weight (0=aus, 1=voll) |
| `_raycastHeight` | float | 0.5 | Raycast-Start über dem Fuß |
| `_raycastDepth` | float | 0.3 | Raycast-Länge unter dem Fuß |
| `_groundLayers` | LayerMask | — | Welche Layer als Boden gelten |
| `_footOffset` | float | 0.02 | Abstand Fußsohle über dem Boden (verhindert Clipping) |
| `_bodyOffsetSmooth` | float | 0.1 | SmoothDamp-Zeit für Body-Offset |
| `_footPositionSmooth` | float | 0.05 | Interpolations-Speed für Fuß-Position |
| `_footRotationSpeed` | float | 10f | Rotations-Interpolation (Slerp Speed) |
| `_maxFootAdjustment` | float | 0.4 | Maximaler Fuß-Versatz (verhindert Überdehnung) |

### Private Felder

```csharp
private bool _isEnabled = true;
private IKManager _ikManager;

// Raycast-Ergebnisse (berechnet in PrepareIK)
private bool _leftFootHit;
private bool _rightFootHit;
private Vector3 _leftFootTarget;
private Vector3 _rightFootTarget;
private Quaternion _leftFootRotation;
private Quaternion _rightFootRotation;

// Body Offset
private float _currentBodyOffset;
private float _bodyOffsetVelocity;
```

### Awake — Registrierung

```csharp
private void Awake()
{
    _ikManager = GetComponent<IKManager>();
    if (_playerController == null)
        _playerController = GetComponentInParent<PlayerController>();
}

private void OnEnable()
{
    _ikManager?.RegisterModule(this);
}

private void OnDisable()
{
    _ikManager?.UnregisterModule(this);
}
```

### PrepareIK — Raycasts

```csharp
public void PrepareIK()
{
    if (!_playerController.IsGrounded)
    {
        _leftFootHit = false;
        _rightFootHit = false;
        _currentBodyOffset = Mathf.SmoothDamp(
            _currentBodyOffset, 0f, ref _bodyOffsetVelocity, _bodyOffsetSmooth);
        return;
    }

    var animator = GetComponent<Animator>();

    // Fuß-Positionen aus der Animation lesen
    Vector3 leftFoot = animator.GetBoneTransform(HumanBodyBones.LeftFoot).position;
    Vector3 rightFoot = animator.GetBoneTransform(HumanBodyBones.RightFoot).position;

    // Raycasts
    _leftFootHit = CastFoot(leftFoot, out _leftFootTarget, out _leftFootRotation);
    _rightFootHit = CastFoot(rightFoot, out _rightFootTarget, out _rightFootRotation);

    // Body Offset berechnen
    float targetBodyOffset = 0f;
    if (_leftFootHit && _rightFootHit)
    {
        float leftDelta = _leftFootTarget.y - leftFoot.y;
        float rightDelta = _rightFootTarget.y - rightFoot.y;
        targetBodyOffset = Mathf.Min(leftDelta, rightDelta);
        targetBodyOffset = Mathf.Min(targetBodyOffset, 0f); // Nur nach unten
    }

    _currentBodyOffset = Mathf.SmoothDamp(
        _currentBodyOffset, targetBodyOffset, ref _bodyOffsetVelocity, _bodyOffsetSmooth);
}
```

### CastFoot Helper

```csharp
private bool CastFoot(Vector3 footPos, out Vector3 targetPos, out Quaternion targetRot)
{
    Vector3 origin = footPos + Vector3.up * _raycastHeight;
    float distance = _raycastHeight + _raycastDepth;

    if (Physics.Raycast(origin, Vector3.down, out RaycastHit hit, distance, _groundLayers))
    {
        targetPos = hit.point + Vector3.up * _footOffset;
        // Fuß-Rotation: Fußsohle liegt auf der Oberfläche
        targetRot = Quaternion.FromToRotation(Vector3.up, hit.normal)
                    * transform.rotation;
        return true;
    }

    targetPos = footPos;
    targetRot = Quaternion.identity;
    return false;
}
```

### ProcessIK — Anwendung

```csharp
public void ProcessIK(Animator animator, int layerIndex)
{
    if (layerIndex != 0) return; // Foot IK nur auf Base Layer

    float effectiveWeight = _weight;

    // Body Offset anwenden (Hüfte absenken)
    if (Mathf.Abs(_currentBodyOffset) > 0.001f)
    {
        Vector3 bodyPos = animator.bodyPosition;
        bodyPos.y += _currentBodyOffset;
        animator.bodyPosition = bodyPos;
    }

    // Left Foot
    if (_leftFootHit)
    {
        animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, effectiveWeight);
        animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, effectiveWeight);
        animator.SetIKPosition(AvatarIKGoal.LeftFoot, _leftFootTarget);
        animator.SetIKRotation(AvatarIKGoal.LeftFoot, _leftFootRotation);
    }
    else
    {
        animator.SetIKPositionWeight(AvatarIKGoal.LeftFoot, 0f);
        animator.SetIKRotationWeight(AvatarIKGoal.LeftFoot, 0f);
    }

    // Right Foot
    if (_rightFootHit)
    {
        animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, effectiveWeight);
        animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, effectiveWeight);
        animator.SetIKPosition(AvatarIKGoal.RightFoot, _rightFootTarget);
        animator.SetIKRotation(AvatarIKGoal.RightFoot, _rightFootRotation);
    }
    else
    {
        animator.SetIKPositionWeight(AvatarIKGoal.RightFoot, 0f);
        animator.SetIKRotationWeight(AvatarIKGoal.RightFoot, 0f);
    }
}
```

### IIKModule Interface Implementation

```csharp
public string Name => "FootIK";
public bool IsEnabled { get => _isEnabled; set => _isEnabled = value; }
public float Weight { get => _weight; set => _weight = Mathf.Clamp01(value); }
```

---

## Zusammenspiel mit GroundingSmoother

Der `GroundingSmoother` (Phase 20) verschiebt das Model-Child nach unten bei Step-Ups. FootIK arbeitet NACH dem GroundingSmoother (selbes LateUpdate, `OnAnimatorIK` läuft nach LateUpdate).

**Timing:**
1. CharacterMotor → teleportiert Capsule bei Step-Up
2. GroundingSmoother (LateUpdate, ExecutionOrder 100) → verschiebt Model-Y
3. FootIK.PrepareIK (LateUpdate, reguläres Timing) → Raycasts von Fuß-Positionen
4. FootIK.ProcessIK (OnAnimatorIK) → IK-Positionen setzen

Da `OnAnimatorIK` nach allen LateUpdates läuft, berücksichtigt FootIK automatisch den GroundingSmoother-Offset. **Keine spezielle Integration nötig.**

---

## Edge Cases

### 1. Treppen mit GroundingSmoother

Auf Treppen smootht der GroundingSmoother den Y-Offset → Füße schweben kurzzeitig. FootIK korrigiert das, indem die Füße per Raycast auf die tatsächliche Stufenoberfläche gesetzt werden.

### 2. Slopes

Auf Slopes zeigt die Fuß-Rotation entlang der Surface-Normalen → Füße liegen flach auf dem Hang. Body Offset ist minimal, da beide Füße ähnlich tief stehen.

### 3. Schmale Kanten (ein Fuß in der Luft)

Wenn ein Fuß keinen Raycast-Hit hat (über einer Kante), wird für diesen Fuß kein IK angewendet → Animation übernimmt. Body Offset basiert nur auf dem Fuß MIT Hit.

### 4. Während Bewegung

Foot IK soll auch während des Laufens aktiv sein, aber der Weight kann bei hoher Geschwindigkeit (Sprint) reduziert werden, da die Schritte zu schnell für sichtbaren IK-Effekt sind.

---

## Verifikation

- [ ] `FootIK.cs` erstellt unter `Runtime/Modules/`
- [ ] Implementiert `IIKModule` Interface vollständig
- [ ] Registriert sich bei `IKManager` in `OnEnable` / `OnDisable`
- [ ] `PrepareIK()` führt Raycasts pro Fuß aus
- [ ] `ProcessIK()` setzt IK Position + Rotation + Body Offset
- [ ] Body Offset: `Mathf.Min(leftDelta, rightDelta)`, nur nach unten
- [ ] `_maxFootAdjustment` begrenzt den Fuß-Versatz
- [ ] Kein IK wenn nicht grounded
- [ ] Kompiliert fehlerfrei

---

## Nächster Schritt

→ [8.4 LookAtIK Modul](8.4-lookat-ik.md)
