# 5.2 AbilityDefinition & AbilityContext

> **Branch:** `feat/ability-package-core` (gleicher Branch wie 5.1)
> **Commit:** `feat(phase-5): 5.2 AbilityDefinition & AbilityContext`

---

## Ziel

Datengetriebene Ability-Konfiguration via ScriptableObject und einen Read-Only Context-Container für Ability-Logik.

---

## Dateien

| Aktion | Pfad |
|--------|------|
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Runtime/Core/AbilityDefinition.cs` |
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Runtime/Core/AbilityContext.cs` |

---

## Detaillierte Anweisungen

### AbilityDefinition (ScriptableObject)

Datencontainer für die statische Konfiguration einer Ability. Wird im Editor erstellt und Abilities zugewiesen.

**Namespace:** `Wiesenwischer.GameKit.Abilities.Core`

```csharp
/// <summary>
/// ScriptableObject-basierte Konfiguration für eine Ability.
/// Definiert statische Eigenschaften wie Cooldown, Priorität, Ressourcenkosten.
/// Wird von konkreten IAbility-Implementierungen referenziert.
/// </summary>
[CreateAssetMenu(
    fileName = "NewAbility",
    menuName = "Wiesenwischer/Abilities/Ability Definition")]
public class AbilityDefinition : ScriptableObject
{
    [Header("Identity")]
    [Tooltip("Eindeutige ID der Ability (wird auch als IAbility.Id verwendet)")]
    public string abilityId;

    [Tooltip("Anzeigename für UI")]
    public string displayName;

    [Tooltip("Icon für AbilityBar UI")]
    public Sprite icon;

    [TextArea(2, 4)]
    [Tooltip("Beschreibung für Tooltips")]
    public string description;

    [Header("Timing")]
    [Tooltip("Cooldown in Sekunden nach Deaktivierung")]
    [Min(0f)]
    public float cooldown;

    [Tooltip("Maximale Dauer der Ability in Sekunden (0 = unbegrenzt)")]
    [Min(0f)]
    public float duration;

    [Header("Priority")]
    [Tooltip("Priorität für Interruption-Logik (höher = kann niedrigere unterbrechen)")]
    public int priority = AbilityPriority.Attack;

    [Header("Conditions")]
    [Tooltip("Ability nur aktivierbar wenn Character am Boden ist")]
    public bool requiresGrounded;

    [Tooltip("Ability blockiert Bewegung während aktiv")]
    public bool blocksMovement;

    [Tooltip("Ability kann durch andere Abilities unterbrochen werden")]
    public bool interruptible = true;

    [Header("Animation")]
    [Tooltip("Name des Animator States für diese Ability (Layer 1)")]
    public string animationStateName;

    [Tooltip("CrossFade-Dauer beim Wechsel zur Ability-Animation")]
    public float animationTransitionDuration = 0.1f;
}
```

### AbilityContext (Read-Only Struct)

Read-Only Container mit Referenzen auf alle relevanten Systeme. Wird vom AbilitySystem vor jedem Aufruf erstellt und an Abilities übergeben.

```csharp
using Wiesenwischer.GameKit.CharacterController.Core;
using Wiesenwischer.GameKit.CharacterController.Core.Motor;
using Wiesenwischer.GameKit.CharacterController.Core.Locomotion;

namespace Wiesenwischer.GameKit.Abilities.Core
{
    /// <summary>
    /// Read-only context container passed to abilities on every call.
    /// Provides access to the character's systems without tight coupling.
    /// </summary>
    public readonly struct AbilityContext
    {
        /// <summary>Referenz auf den PlayerController (Orchestrator).</summary>
        public PlayerController Player { get; }

        /// <summary>Referenz auf den CharacterMotor (Positions/Velocity-Daten).</summary>
        public CharacterMotor Motor { get; }

        /// <summary>Referenz auf die CharacterLocomotion (Grounding, Movement).</summary>
        public CharacterLocomotion Locomotion { get; }

        /// <summary>Referenz auf den AnimationController (Layer-Steuerung).</summary>
        public IAnimationController AnimationController { get; }

        /// <summary>Ob der Character aktuell am Boden ist.</summary>
        public bool IsGrounded => Locomotion != null && Locomotion.IsGrounded;

        /// <summary>Aktuelle Geschwindigkeit des Characters.</summary>
        public Vector3 Velocity => Motor != null ? Motor.Velocity : Vector3.zero;

        public AbilityContext(
            PlayerController player,
            CharacterMotor motor,
            CharacterLocomotion locomotion,
            IAnimationController animationController)
        {
            Player = player;
            Motor = motor;
            Locomotion = locomotion;
            AnimationController = animationController;
        }
    }
}
```

---

## Design-Entscheidungen

### Warum ScriptableObject für AbilityDefinition?

- **Datengetrieben:** Designer können Abilities im Editor erstellen und tunen ohne Code
- **Wiederverwendbar:** Mehrere Ability-Instanzen können die gleiche Definition teilen
- **Serialisierbar:** Einfach zu speichern und laden
- **Addressable-ready:** Kann später über Addressables geladen werden

### Warum `readonly struct` für AbilityContext?

- **Keine Allokation:** Struct wird auf dem Stack erstellt, kein GC-Druck
- **Read-Only:** Abilities können den Context nicht verändern
- **Frische Daten:** Wird jeden Frame neu erstellt → immer aktuell

### Warum kein Resource-System (Mana/Stamina)?

- Phase 5 baut nur die Infrastruktur
- Mana/Stamina erfordert ein eigenes Resource-System (Character Stats)
- Kann später als `AbilityDefinition`-Erweiterung oder separates System hinzugefügt werden
- `AbilityDefinition` kann problemlos um `resourceCost` erweitert werden

---

## Verifikation

- [ ] `AbilityDefinition.cs` erstellt mit allen Feldern
- [ ] CreateAssetMenu konfiguriert (`Wiesenwischer/Abilities/Ability Definition`)
- [ ] `AbilityContext.cs` als `readonly struct` implementiert
- [ ] `AbilityContext` enthält Referenzen auf Player, Motor, Locomotion, AnimationController
- [ ] Convenience-Properties `IsGrounded` und `Velocity` funktionieren
- [ ] Keine GC-Allokationen durch AbilityContext
- [ ] Kompiliert fehlerfrei

---

## Nächster Schritt

→ [5.3 AbilitySystem Manager](5.3-ability-system-manager.md)
