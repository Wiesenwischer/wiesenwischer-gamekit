# 5.5 PlayerController Integration & Tests

> **Branch:** `feat/ability-integration-tests`
> **Commit:** `feat(phase-5): 5.5 PlayerController Integration & Tests`

---

## Ziel

AbilitySystem in den PlayerController-Lifecycle einbinden und vollständige Tests für das gesamte Ability-Framework schreiben.

---

## Dateien

| Aktion | Pfad |
|--------|------|
| Bearbeiten | `Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/PlayerController.cs` |
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Tests/Runtime/Core/AbilitySystemTests.cs` |
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Tests/Runtime/Core/MockAbility.cs` |
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Tests/Runtime/Core/AbilityPriorityTests.cs` |

---

## Detaillierte Anweisungen

### PlayerController Integration

Der PlayerController bekommt eine optionale Referenz auf das AbilitySystem. Das System wird im Update-Loop geticked.

```csharp
// Ergänzungen in PlayerController.cs:

// === Feld ===
private AbilitySystem _abilitySystem; // Cached in Awake (optional)

// === Property ===
public AbilitySystem AbilitySystem => _abilitySystem;

// === Awake (Ergänzung) ===
_abilitySystem = GetComponent<AbilitySystem>(); // Optional: kann null sein

// === Update (Ergänzung nach State Machine Update) ===
_abilitySystem?.Tick(Time.deltaTime);
```

**Wichtig:**
- AbilitySystem ist **optional** — PlayerController funktioniert ohne (Backward-Kompatibilität)
- `GetComponent<AbilitySystem>()` in Awake, nicht jedes Frame
- Tick wird **nach** der State Machine aufgerufen (Abilities reagieren auf aktuellen State)

### Abhängigkeit: CharacterController.Core → Abilities.Core

Damit `PlayerController` das `AbilitySystem` referenzieren kann, muss die CharacterController.Core asmdef eine Referenz auf Abilities.Core bekommen.

**Alternativ:** PlayerController referenziert AbilitySystem nur per `GetComponent<AbilitySystem>()` ohne explizite Typ-Referenz — dann ist keine asmdef-Abhängigkeit nötig. Dies erfordert aber eine Interface-Abstraktion.

**Empfohlener Ansatz:** Interface `IAbilitySystem` im CharacterController.Core definieren, AbilitySystem in Abilities.Core implementiert es. So zeigt die Abhängigkeit in die richtige Richtung.

```
CharacterController.Core:
  - IAbilitySystem (Interface)
  - PlayerController referenziert IAbilitySystem

Abilities.Core:
  - AbilitySystem : MonoBehaviour, IAbilitySystem
  - Depends on CharacterController.Core
```

```csharp
// In CharacterController.Core:
namespace Wiesenwischer.GameKit.CharacterController.Core
{
    /// <summary>
    /// Interface for the ability system, allowing PlayerController to
    /// tick abilities without a direct dependency on Abilities.Core.
    /// </summary>
    public interface IAbilitySystem
    {
        void Tick(float deltaTime);
        bool HasActiveAbility { get; }
    }
}

// PlayerController nutzt:
private IAbilitySystem _abilitySystem;
// Gesetzt via GetComponent oder Injection
```

---

## Test-Strategie

### MockAbility (Test-Helper)

```csharp
namespace Wiesenwischer.GameKit.Abilities.Core.Tests
{
    /// <summary>
    /// Configurable mock ability for unit testing the AbilitySystem.
    /// </summary>
    public class MockAbility : IAbility
    {
        public string Id { get; set; } = "mock_ability";
        public AbilityState State { get; set; } = AbilityState.Ready;
        public int Priority { get; set; } = AbilityPriority.Attack;

        // Configurable behavior
        public bool CanActivateResult { get; set; } = true;

        // Call tracking
        public int ActivateCallCount { get; private set; }
        public int DeactivateCallCount { get; private set; }
        public int TickCallCount { get; private set; }

        public bool CanActivate(AbilityContext context) => CanActivateResult;
        public void Activate(AbilityContext context) { State = AbilityState.Active; ActivateCallCount++; }
        public void Tick(AbilityContext context, float deltaTime) { TickCallCount++; }
        public void Deactivate(AbilityContext context) { State = AbilityState.Ready; DeactivateCallCount++; }
    }
}
```

### AbilitySystemTests

| Kategorie | Test | Beschreibung |
|-----------|------|-------------|
| **Registration** | `Register_ReturnsTrue_ForNewAbility` | Erstmalige Registrierung erfolgreich |
| | `Register_ReturnsFalse_ForDuplicateId` | Doppelte ID wird abgelehnt |
| | `Unregister_RemovesAbility` | Ability wird entfernt |
| | `Unregister_DeactivatesActive` | Aktive Ability wird deaktiviert bei Unregister |
| **Activation** | `TryActivate_CallsActivate_WhenReady` | Ability wird aktiviert wenn bereit |
| | `TryActivate_ReturnsFalse_WhenOnCooldown` | Cooldown blockiert Aktivierung |
| | `TryActivate_ReturnsFalse_WhenCanActivateFalse` | CanActivate=false blockiert |
| | `TryActivate_ReturnsFalse_WhenNotRegistered` | Unbekannte ID gibt false |
| **Priority** | `TryActivate_InterruptsLowerPriority` | Höhere Priorität unterbricht niedrigere |
| | `TryActivate_FailsAgainstHigherPriority` | Niedrigere Priorität kann nicht unterbrechen |
| | `TryActivate_FailsAgainstEqualPriority` | Gleiche Priorität ersetzt nicht |
| **Cooldown** | `Cooldown_DecreasesOverTime` | Timer zählt runter |
| | `Cooldown_ResetsToReady_WhenExpired` | State wird Ready nach Ablauf |
| | `Cooldown_FiresEvent_WhenComplete` | Event wird gefeuert |
| **Deactivation** | `Deactivate_StartsCooldown` | Cooldown beginnt nach Deactivate |
| | `Deactivate_FiresEvent` | OnAbilityDeactivated gefeuert |
| **Cancel** | `Cancel_FiresCancelEvent` | OnAbilityCancelled statt Deactivated |
| **Duration** | `ActiveAbility_AutoDeactivates_AfterDuration` | Ability endet nach Dauer |
| **Tick** | `Tick_CallsAbilityTick_WhenActive` | Aktive Ability wird geticked |
| | `Tick_DoesNotCallTick_WhenInactive` | Inaktive Ability wird nicht geticked |
| **Events** | `Events_FireInCorrectOrder` | Activate → Tick → Deactivate Events |

### AbilityPriorityTests

| Test | Beschreibung |
|------|-------------|
| `Constants_HaveCorrectOrder` | Interaction < Utility < Attack < Dodge < Ultimate < ForcedStatus |
| `ForcedStatus_InterruptsEverything` | Priority 100 unterbricht alle anderen |

---

## Verifikation

- [ ] `IAbilitySystem` Interface in CharacterController.Core erstellt
- [ ] PlayerController referenziert `IAbilitySystem` (optional, null-safe)
- [ ] AbilitySystem implementiert `IAbilitySystem`
- [ ] `AbilitySystem.Tick()` wird in PlayerController.Update() aufgerufen
- [ ] Keine zirkuläre Dependency (CharacterController.Core ← Abilities.Core)
- [ ] MockAbility mit konfigurierbarem Verhalten
- [ ] 20+ Unit Tests alle grün
- [ ] Tests decken ab: Registration, Activation, Priority, Cooldown, Duration, Cancel, Events
- [ ] Kompilierung fehlerfrei (inkl. Test-Assemblies)

---

## Phase 5 abgeschlossen

Nach erfolgreichem Abschluss aller Schritte:
1. Alle Feature-Branches in Integration-Branch mergen
2. Integration-Branch testen (alle Tests grün)
3. Weiter mit Phase 9 (Combat Abilities) oder anderer priorisierter Phase
