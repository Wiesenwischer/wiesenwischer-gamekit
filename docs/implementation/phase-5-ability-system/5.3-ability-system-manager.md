# 5.3 AbilitySystem Manager

> **Branch:** `feat/ability-system-manager`
> **Commit:** `feat(phase-5): 5.3 AbilitySystem Manager`

---

## Ziel

Zentraler Manager für Ability-Lifecycle: Registrierung, Aktivierung, Deaktivierung, Cooldown-Tracking und Priority-basierte Interruption.

---

## Dateien

| Aktion | Pfad |
|--------|------|
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Runtime/Core/AbilitySystem.cs` |
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Runtime/Core/AbilitySlot.cs` |

---

## Detaillierte Anweisungen

### AbilitySlot (Interner Wrapper)

Tracking-Container für eine registrierte Ability (Cooldown-Timer, State-Management).

```csharp
namespace Wiesenwischer.GameKit.Abilities.Core
{
    /// <summary>
    /// Internal tracking wrapper for a registered ability.
    /// Manages cooldown timer and state transitions.
    /// </summary>
    internal class AbilitySlot
    {
        public IAbility Ability { get; }
        public AbilityDefinition Definition { get; }
        public float CooldownRemaining { get; set; }

        public bool IsOnCooldown => CooldownRemaining > 0f;
        public bool IsActive => Ability.State == AbilityState.Active;

        public AbilitySlot(IAbility ability, AbilityDefinition definition) { ... }
    }
}
```

### AbilitySystem (MonoBehaviour)

**Namespace:** `Wiesenwischer.GameKit.Abilities.Core`

Der AbilitySystem Manager wird auf dem Player Root-Object platziert (neben PlayerController).

#### Öffentliche API

```csharp
/// <summary>
/// Central ability lifecycle manager.
/// Handles registration, activation, deactivation, cooldowns and priority.
/// Placed on the Player root alongside PlayerController.
/// </summary>
public class AbilitySystem : MonoBehaviour
{
    // === Events ===
    public event System.Action<IAbility> OnAbilityActivated;
    public event System.Action<IAbility> OnAbilityDeactivated;
    public event System.Action<IAbility> OnAbilityCancelled;
    public event System.Action<IAbility> OnAbilityCooldownComplete;

    // === Registration ===
    /// <summary>Register an ability with its definition. Returns false if ID already registered.</summary>
    public bool RegisterAbility(IAbility ability, AbilityDefinition definition);

    /// <summary>Unregister an ability by ID. Deactivates if currently active.</summary>
    public bool UnregisterAbility(string abilityId);

    // === Activation ===
    /// <summary>
    /// Try to activate an ability by ID.
    /// Checks: registered? not on cooldown? CanActivate? priority?
    /// If a lower-priority ability is active and interruptible, it gets cancelled first.
    /// </summary>
    public bool TryActivate(string abilityId);

    /// <summary>Deactivate an ability by ID. Starts cooldown.</summary>
    public void Deactivate(string abilityId);

    /// <summary>Cancel an ability (interrupted by priority or external force).</summary>
    public void Cancel(string abilityId);

    // === Queries ===
    /// <summary>Get an ability by ID. Returns null if not registered.</summary>
    public IAbility GetAbility(string abilityId);

    /// <summary>Whether any ability is currently active.</summary>
    public bool HasActiveAbility { get; }

    /// <summary>The currently active ability (null if none).</summary>
    public IAbility ActiveAbility { get; }

    /// <summary>Remaining cooldown for an ability (0 if ready).</summary>
    public float GetCooldownRemaining(string abilityId);
}
```

#### Internes Verhalten

```
Tick(deltaTime):
  1. Cooldown-Timer für alle registrierten Abilities herunterzählen
     - Bei Ablauf: State → Ready, Event OnAbilityCooldownComplete
  2. Aktive Ability ticken (Ability.Tick(context, deltaTime))
     - Falls duration > 0 und abgelaufen: automatisch Deactivate()
```

```
TryActivate(abilityId):
  1. Ability finden → nicht gefunden? return false
  2. Cooldown prüfen → on cooldown? return false
  3. CanActivate(context) prüfen → false? return false
  4. Aktive Ability prüfen:
     a. Keine aktive → direkt aktivieren
     b. Gleiche Ability bereits aktiv → return false
     c. Neue Priority >= aktive Priority UND aktive.interruptible:
        → Cancel aktive Ability, dann neue aktivieren
     d. Neue Priority < aktive Priority → return false
  5. Ability.Activate(context) aufrufen
  6. State → Active
  7. Event OnAbilityActivated feuern
  8. return true
```

```
Deactivate(abilityId):
  1. Ability finden → nicht gefunden oder nicht aktiv? return
  2. Ability.Deactivate(context) aufrufen
  3. State → Cooldown (wenn cooldown > 0) oder Ready
  4. CooldownRemaining setzen
  5. Event OnAbilityDeactivated feuern
```

```
Cancel(abilityId):
  1. Wie Deactivate, aber feuert OnAbilityCancelled statt OnAbilityDeactivated
  2. Ability soll wissen ob sie normal endete oder unterbrochen wurde
```

#### Interne Daten

```csharp
// Registered abilities indexed by ID
private readonly Dictionary<string, AbilitySlot> _slots = new();

// Currently active ability (nur eine gleichzeitig in Phase 5)
private AbilitySlot _activeSlot;

// Context wird jeden Frame neu erstellt (readonly struct, kein GC)
private AbilityContext _context;

// Cached references (gesetzt in Awake)
private PlayerController _player;
private CharacterMotor _motor;
private CharacterLocomotion _locomotion;
private IAnimationController _animationController;
```

#### Lifecycle

```csharp
private void Awake()
{
    _player = GetComponent<PlayerController>();
    _motor = GetComponent<CharacterMotor>();
    _locomotion = GetComponent<CharacterLocomotion>();
    // AnimationController wird vom PlayerController bereitgestellt
}

/// <summary>Called by PlayerController in its Update loop.</summary>
public void Tick(float deltaTime)
{
    UpdateContext();
    UpdateCooldowns(deltaTime);
    TickActiveAbility(deltaTime);
}
```

---

## Design-Entscheidungen

### Nur eine aktive Ability gleichzeitig (Phase 5)

Phase 5 unterstützt nur **eine** aktive Ability zur gleichen Zeit. Dies vereinfacht:
- Priority-Logik (nur 1:1 Vergleich)
- Animation Layer Management (Layer 1 = 0 oder 1)
- Debugging und Testing

Phase 9 kann dies auf mehrere gleichzeitige Abilities erweitern (z.B. Buff + Attack).

### Warum Dictionary statt List?

- Abilities werden per `string Id` angesprochen
- O(1) Lookup statt O(n) Suche
- Keine Sortierung nötig (Priority wird nur bei Activation geprüft)

### Events statt Callbacks

- `System.Action<IAbility>` Events sind Unity-Standard
- Lose Kopplung: UI, Sound, Netzwerk können sich subscribed
- Kein Zwang für Subscriber (optional)

---

## Verifikation

- [ ] `AbilitySystem.cs` erstellt als MonoBehaviour
- [ ] `AbilitySlot.cs` erstellt als interner Wrapper
- [ ] Registration: RegisterAbility/UnregisterAbility funktioniert
- [ ] Activation: TryActivate prüft Cooldown, CanActivate, Priority
- [ ] Deactivation: Deactivate startet Cooldown korrekt
- [ ] Cancellation: Cancel feuert korrektes Event
- [ ] Cooldown-Timer: Zählt runter, wechselt zu Ready bei Ablauf
- [ ] Duration: Automatische Deaktivierung bei Ablauf
- [ ] Events: Alle 4 Events feuern korrekt
- [ ] Keine GC-Allokationen im Tick (AbilityContext ist struct)
- [ ] Kompiliert fehlerfrei

---

## Nächster Schritt

→ [5.4 Animation Layer Integration](5.4-animation-layer-integration.md)
