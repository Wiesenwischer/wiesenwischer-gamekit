# 5.4 Animation Layer Integration

> **Branch:** `feat/ability-system-manager` (gleicher Branch wie 5.3)
> **Commit:** `feat(phase-5): 5.4 Animation Layer Integration`

---

## Ziel

AbilitySystem mit dem Animation Layer 1 (Upper Body) verdrahten, sodass Abilities Animationen auf Layer 1 abspielen und die Layer-Weight automatisch gesteuert wird.

---

## Dateien

| Aktion | Pfad |
|--------|------|
| Erstellen | `Packages/Wiesenwischer.GameKit.Abilities.Core/Runtime/Core/IAbilityAnimationHandler.cs` |
| Bearbeiten | `Packages/Wiesenwischer.GameKit.Abilities.Core/Runtime/Core/AbilitySystem.cs` |

---

## Bestehende Infrastruktur

Bereits implementiert in Phase 3/4:

```csharp
// IAnimationController (CharacterController.Core)
void SetAbilityLayerWeight(float weight);  // Layer 1 Weight (0..1)
void PlayState(CharacterAnimationState state);
void PlayState(CharacterAnimationState state, float transitionDuration);

// AnimatorParameterBridge nutzt Animator.CrossFade() direkt
```

**Layer 1 im Animator Controller:** Existiert bereits (Upper Body Mask), ist aktuell leer. Ability-Animationen werden dort hinzugefügt wenn konkrete Abilities implementiert werden (Phase 9).

---

## Detaillierte Anweisungen

### IAbilityAnimationHandler Interface

Optionales Interface für Abilities die Animationen abspielen. Nicht jede Ability braucht eine Animation (z.B. passive Buffs).

```csharp
namespace Wiesenwischer.GameKit.Abilities.Core
{
    /// <summary>
    /// Optional interface for abilities that play animations on the Ability Layer.
    /// Implement this alongside IAbility to enable animation integration.
    /// </summary>
    public interface IAbilityAnimationHandler
    {
        /// <summary>
        /// Name des Animator-States auf Layer 1.
        /// Wird per Animator.CrossFade() getriggert.
        /// </summary>
        string AnimationStateName { get; }

        /// <summary>CrossFade-Dauer für den Übergang zur Ability-Animation.</summary>
        float TransitionDuration { get; }

        /// <summary>
        /// Ob die Animation gerade abgeschlossen ist.
        /// Wird vom AbilitySystem abgefragt für auto-deactivate bei Animation-Ende.
        /// </summary>
        bool IsAnimationComplete(AbilityContext context);
    }
}
```

### AbilitySystem — Animation-Erweiterung

Dem AbilitySystem die Animation-Layer-Steuerung hinzufügen:

```csharp
// In AbilitySystem.cs ergänzen:

// === Activation (Ergänzung nach Ability.Activate) ===
private void HandleAbilityAnimation(IAbility ability, bool activating)
{
    if (activating)
    {
        // Layer 1 einblenden
        _animationController?.SetAbilityLayerWeight(1f);

        // Animation starten falls die Ability eine hat
        if (ability is IAbilityAnimationHandler animHandler
            && !string.IsNullOrEmpty(animHandler.AnimationStateName))
        {
            // Direkt via Animator.CrossFade (nutzt bestehendes System)
            _animationController?.PlayAbilityAnimation(
                animHandler.AnimationStateName,
                animHandler.TransitionDuration);
        }
    }
    else
    {
        // Layer 1 ausblenden
        _animationController?.SetAbilityLayerWeight(0f);
    }
}
```

### IAnimationController — Erweiterung

Eine neue Methode zum Abspielen von Ability-Animationen auf Layer 1:

```csharp
// Ergänzung in IAnimationController:
/// <summary>
/// Spielt eine Animation auf dem Ability Layer (Layer 1) ab.
/// Nutzt CrossFade mit der angegebenen Transition-Dauer.
/// </summary>
void PlayAbilityAnimation(string stateName, float transitionDuration);
```

### AnimatorParameterBridge — Implementierung

```csharp
// Ergänzung in AnimatorParameterBridge:
public void PlayAbilityAnimation(string stateName, float transitionDuration)
{
    if (_animator != null && !string.IsNullOrEmpty(stateName))
    {
        _animator.CrossFade(stateName, transitionDuration, 1); // Layer 1
    }
}
```

---

## Flow bei Ability-Aktivierung

```
AbilitySystem.TryActivate("sword_slash")
  ├── ability.Activate(context)              // Ability-Logik
  ├── SetAbilityLayerWeight(1f)              // Layer 1 einblenden
  └── CrossFade("SwordSlash", 0.1f, layer:1) // Animation starten

AbilitySystem.Tick()
  ├── ability.Tick(context, dt)              // Ability-Update
  └── if animHandler.IsAnimationComplete()   // Animation-Ende prüfen
        → Deactivate()                       // Auto-Deactivate

AbilitySystem.Deactivate("sword_slash")
  ├── ability.Deactivate(context)            // Cleanup
  └── SetAbilityLayerWeight(0f)              // Layer 1 ausblenden
```

---

## Design-Entscheidungen

### Warum `IAbilityAnimationHandler` statt direkt in `IAbility`?

- Nicht jede Ability hat Animationen (passive Buffs, Auren)
- Interface Segregation Principle: Abilities implementieren nur was sie brauchen
- `ability is IAbilityAnimationHandler` Pattern ist sauber und erweiterbar

### Warum harte Layer-Weight (0/1) statt Blending?

- Phase 5 nutzt einfaches Ein/Aus für Layer 1
- Smooth-Blending (Weight-Interpolation) kann in Phase 9 hinzugefügt werden
- Einfacher zu debuggen und zu testen

### Warum kein eigener Animation State in `CharacterAnimationState` Enum?

- Ability-Animationen nutzen String-basiertes `CrossFade` statt Enum
- Das Enum ist für Movement States (Locomotion, Jump, Fall, Land)
- Abilities können beliebig viele verschiedene Animationen haben → Strings sind flexibler

---

## Verifikation

- [ ] `IAbilityAnimationHandler.cs` erstellt
- [ ] `AbilitySystem` ruft `SetAbilityLayerWeight(1f)` bei Activation auf
- [ ] `AbilitySystem` ruft `SetAbilityLayerWeight(0f)` bei Deactivation auf
- [ ] `PlayAbilityAnimation()` in IAnimationController hinzugefügt
- [ ] `PlayAbilityAnimation()` in AnimatorParameterBridge implementiert
- [ ] Layer 1 CrossFade funktioniert (manueller Test mit Debug-Ability)
- [ ] Layer Weight wird bei Cancel korrekt auf 0 gesetzt
- [ ] Kompiliert fehlerfrei

---

## Nächster Schritt

→ [5.5 PlayerController Integration & Tests](5.5-integration-tests.md)
