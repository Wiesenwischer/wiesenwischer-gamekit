# 3.2 State Animation-Trigger

**Commit:** `feat(phase-3): 3.2 State Animation-Trigger`
**Branch:** `feat/state-animation-triggers`

---

## Ziel

Die relevanten Movement States um Animation-Trigger-Aufrufe erweitern, damit der Animator bei State-Wechseln die richtigen Animationen abspielt.

---

## Konzept

Kontinuierliche Parameter (Speed, IsGrounded, VerticalVelocity) werden **automatisch** von der `AnimatorParameterBridge` in `LateUpdate()` aus `ReusableData` gelesen. Dafür sind **keine Änderungen an den States** nötig.

Trigger-basierte Animationen (Jump, Land) müssen **explizit** von den States aufgerufen werden, da sie einmalige Events sind:

```
State.OnEnter()  ──>  Player.AnimationController?.TriggerJump()
                      Player.AnimationController?.TriggerLanding(bool)
```

---

## Änderungen

### 1. PlayerJumpingState

**Datei:** `Packages/.../Runtime/Core/StateMachine/States/Airborne/PlayerJumpingState.cs`

In `OnEnter()` den Jump-Trigger auslösen:

```csharp
protected override void OnEnter()
{
    base.OnEnter();

    // Animation-Trigger
    Player.AnimationController?.TriggerJump();

    // Bestehende Logik bleibt unverändert:
    ReusableData.JumpRequested = true;
    _jumpButtonReleased = false;
    _jumpImpulseConfirmed = false;
}
```

> **Warum in OnEnter?** Der Jump-Trigger muss genau einmal beim State-Eintritt gefeuert werden. Die Jump-Animation startet sofort, während die physikalische Kraft im nächsten FixedTick angewandt wird.

---

### 2. PlayerSoftLandingState

**Datei:** `Packages/.../Runtime/Core/StateMachine/States/Grounded/PlayerSoftLandingState.cs`

In `OnEnter()` die Soft-Landing-Animation triggern:

```csharp
protected override void OnEnter()
{
    base.OnEnter();

    // Animation-Trigger (Soft Landing)
    Player.AnimationController?.TriggerLanding(false);
}
```

> **Soft Landing** ist eine kurze, kaum sichtbare Landung. Der Bool `false` setzt `HardLanding = false` im Animator, wodurch die Transition zur Soft-Land-Animation gewählt wird.

---

### 3. PlayerHardLandingState

**Datei:** `Packages/.../Runtime/Core/StateMachine/States/Grounded/PlayerHardLandingState.cs`

In `OnEnter()` die Hard-Landing-Animation triggern:

```csharp
protected override void OnEnter()
{
    base.OnEnter();

    // Animation-Trigger (Hard Landing)
    Player.AnimationController?.TriggerLanding(true);

    // Bestehende Logik bleibt unverändert:
    float landingSpeed = Mathf.Abs(ReusableData.LandingVelocity);
    // ... Recovery-Timer-Berechnung etc.
}
```

> **Hard Landing** setzt `HardLanding = true` und triggert `Land`. Der Animator wählt per Transition-Condition die Hard-Land-Animation (längere Recovery).

---

### 4. Keine Änderungen nötig für:

| State | Grund |
|-------|-------|
| `PlayerIdlingState` | Speed=0 wird automatisch von Bridge gesetzt → Blend Tree zeigt Idle |
| `PlayerWalkingState` | Speed≈0.5 wird automatisch gesetzt → Blend Tree zeigt Walk |
| `PlayerRunningState` | Speed≈1.0 wird automatisch gesetzt → Blend Tree zeigt Run |
| `PlayerSprintingState` | Speed≈1.5 wird automatisch gesetzt → Blend Tree zeigt Sprint |
| `PlayerFallingState` | IsGrounded=false + VerticalVelocity<0 löst automatisch Fall-Transition aus |
| `PlayerGroundedState` | IsGrounded wird automatisch gesetzt |
| `PlayerAirborneState` | IsGrounded wird automatisch gesetzt |

Die Locomotion-Animationen funktionieren rein über die kontinuierlichen Parameter. Nur die einmaligen Events (Jump, Land) brauchen explizite Trigger.

---

## Zusammenfassung der Trigger

| State | Methode | Trigger | Animator-Effekt |
|-------|---------|---------|-----------------|
| JumpingState | `OnEnter()` | `TriggerJump()` | `Jump`-Trigger → Jump-Animation |
| SoftLandingState | `OnEnter()` | `TriggerLanding(false)` | `HardLanding=false` + `Land`-Trigger → SoftLand |
| HardLandingState | `OnEnter()` | `TriggerLanding(true)` | `HardLanding=true` + `Land`-Trigger → HardLand |

---

## Verifikation

- [ ] `PlayerJumpingState.OnEnter()` ruft `Player.AnimationController?.TriggerJump()` auf
- [ ] `PlayerSoftLandingState.OnEnter()` ruft `Player.AnimationController?.TriggerLanding(false)` auf
- [ ] `PlayerHardLandingState.OnEnter()` ruft `Player.AnimationController?.TriggerLanding(true)` auf
- [ ] Null-Conditional `?.` wird überall verwendet (robuster Code ohne Animator)
- [ ] Bestehende State-Logik ist **unverändert** (nur Animation-Zeilen hinzugefügt)
- [ ] Keine neuen Using-Statements nötig (IAnimationController über Player.AnimationController)
- [ ] Alle Packages kompilieren fehlerfrei

### Compiler prüfen

```bash
powershell -Command "Get-Content 'C:\Users\marcu\AppData\Local\Unity\Editor\Editor.log' -Tail 100 | Select-String -Pattern 'error|CS\d{4}'"
```

---

## Dateien nach diesem Schritt

```
Packages/Wiesenwischer.GameKit.CharacterController.Core/
├── Runtime/Core/StateMachine/States/
│   ├── Airborne/
│   │   ├── PlayerJumpingState.cs           (GEÄNDERT - TriggerJump)
│   │   └── PlayerFallingState.cs           (unverändert)
│   └── Grounded/
│       ├── PlayerSoftLandingState.cs       (GEÄNDERT - TriggerLanding)
│       ├── PlayerHardLandingState.cs       (GEÄNDERT - TriggerLanding)
│       ├── PlayerIdlingState.cs            (unverändert)
│       └── Moving/
│           ├── PlayerWalkingState.cs       (unverändert)
│           ├── PlayerRunningState.cs       (unverändert)
│           └── PlayerSprintingState.cs     (unverändert)
```

---

## Nächster Schritt

[3.3 Player Prefab zusammenbauen](3.3-player-prefab.md)
