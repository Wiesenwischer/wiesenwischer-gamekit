# 21.4 PlayerSlidingState implementieren

> **Commit:** `feat(phase-21): 21.4 PlayerSlidingState`
> **Branch:** `feat/slide-state`

---

## Ziel

Neuen `PlayerSlidingState` als eigenständigen State (nicht unter `PlayerGroundedState`) implementieren und in die `PlayerMovementStateMachine` registrieren.

---

## Anweisungen

### 1. Verzeichnis erstellen

```
Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/States/PlayerSlidingState.cs
```

> Der State liegt direkt unter `States/` (nicht unter `Grounded/` oder `Airborne/`), da er einen Hybrid-Zustand darstellt: Bodenkontakt, aber nicht stabil.

### 2. PlayerSlidingState implementieren

```csharp
using UnityEngine;

namespace Wiesenwischer.GameKit.CharacterController.Core.StateMachine.States
{
    /// <summary>
    /// State für das Rutschen auf steilen Hängen (SlopeAngle > MaxSlopeAngle).
    /// Hat Bodenkontakt, ist aber nicht "stabil geerdet" — eigenständiger State.
    /// </summary>
    public class PlayerSlidingState : PlayerMovementState
    {
        private float _slideStartTime;

        public PlayerSlidingState(PlayerMovementStateMachine stateMachine)
            : base(stateMachine) { }

        protected override void OnEnter()
        {
            _slideStartTime = Time.time;

            // Slide-Intent aktivieren
            Player.Locomotion.SetSliding(true);

            // Step Detection deaktivieren (keine Steps auf steilen Slopes)
            ReusableData.StepDetectionEnabled = false;

            // Sprint deaktivieren
            ReusableData.ShouldSprint = false;

            // Animation abspielen
            Player.AnimationController?.PlayState(
                Core.Animation.CharacterAnimationState.Slide);

            // Rotation in Rutsch-Richtung
            UpdateRotationToSlideDirection();
        }

        protected override void OnExit()
        {
            // Slide-Intent deaktivieren
            Player.Locomotion.SetSliding(false);

            // Step Detection wieder aktivieren
            ReusableData.StepDetectionEnabled = true;
        }

        protected override void OnUpdate()
        {
            float timeInSlide = Time.time - _slideStartTime;

            // MinSlideTime einhalten (Flacker-Schutz)
            if (timeInSlide < Config.MinSlideTime)
                return;

            CheckExitConditions();
        }

        protected override void OnHandleInput()
        {
            // Jump-Check (optional, konfigurierbar)
            if (Config.CanJumpFromSlide && ReusableData.JumpPressed && ReusableData.JumpWasReleased)
            {
                // Reduzierte Sprungkraft
                ReusableData.JumpWasReleased = false;
                ChangeState(StateMachine.JumpingState);
                return;
            }
        }

        protected override void OnPhysicsUpdate()
        {
            // Rotation Richtung Hangabwärts (smooth)
            UpdateRotationToSlideDirection();
        }

        // --- Private Methoden ---

        private void CheckExitConditions()
        {
            var groundInfo = Player.Locomotion.GroundInfo;

            // 1. Boden verloren → Falling
            if (!Player.Locomotion.Motor.GroundingStatus.FoundAnyGround)
            {
                ChangeState(StateMachine.FallingState);
                return;
            }

            // 2. Slope wieder begehbar (mit Hysterese)
            float exitAngle = Config.MaxSlopeAngle - Config.SlideExitHysteresis;
            if (groundInfo.SlopeAngle < exitAngle)
            {
                TransitionToGroundedState();
                return;
            }
        }

        private void TransitionToGroundedState()
        {
            if (ReusableData.MoveInput.sqrMagnitude > 0.01f)
            {
                // Spieler hat Input → in Bewegung übergehen
                if (ReusableData.ShouldWalk)
                    ChangeState(StateMachine.WalkingState);
                else
                    ChangeState(StateMachine.RunningState);
            }
            else
            {
                ChangeState(StateMachine.IdlingState);
            }
        }

        private void UpdateRotationToSlideDirection()
        {
            var groundNormal = Player.Locomotion.GroundInfo.GroundNormal;
            Vector3 slideDirection = Vector3.ProjectOnPlane(Vector3.down, groundNormal).normalized;

            if (slideDirection.sqrMagnitude < 0.001f)
                return;

            // Smooth Rotation Richtung Rutsch-Richtung
            Quaternion targetRotation = Quaternion.LookRotation(slideDirection, Vector3.up);
            Player.transform.rotation = Quaternion.RotateTowards(
                Player.transform.rotation,
                targetRotation,
                Config.RotationSpeed * Time.deltaTime);
        }
    }
}
```

### 3. PlayerMovementStateMachine erweitern

**Datei:** `Packages/.../StateMachine/PlayerMovementStateMachine.cs`

Neues Property und Instanziierung:

```csharp
public PlayerSlidingState SlidingState { get; }

// Im Constructor:
SlidingState = new PlayerSlidingState(this);
```

### 4. Jump-Kraft-Modifikation (optional)

Falls `CanJumpFromSlide = true`, muss die Sprungkraft im JumpingState reduziert werden. Zwei Optionen:

**Option A (einfach):** ReusableData-Flag setzen
```csharp
// In PlayerSlidingState.OnHandleInput():
ReusableData.CurrentJumpForce = Config.SlideJumpForceMultiplier;
```

**Option B (Intent):** JumpModule prüft ob aus Slide gesprungen wird
- Abhängig von der bestehenden Jump-Implementierung

> Welche Option gewählt wird, hängt davon ab, wie `CurrentJumpForce` aktuell verwendet wird. Bestehenden Code prüfen!

### 5. Kompilierung prüfen

```bash
powershell -Command "Get-Content 'C:\Users\marcu\AppData\Local\Unity\Editor\Editor.log' -Tail 100 | Select-String -Pattern 'error|CS\d{4}'"
```

---

## Verifikation

- [ ] `PlayerSlidingState` erbt von `PlayerMovementState` (nicht GroundedState)
- [ ] `SetSliding(true)` wird bei Enter aufgerufen
- [ ] `SetSliding(false)` wird bei Exit aufgerufen
- [ ] MinSlideTime wird eingehalten (kein sofortiger Exit)
- [ ] Hysterese-Check: Exit erst bei `SlopeAngle < MaxSlopeAngle - Hysteresis`
- [ ] Bodenverlust → Falling Transition
- [ ] Optional: Jump aus Slide funktioniert mit reduzierter Kraft
- [ ] `PlayerMovementStateMachine.SlidingState` existiert
- [ ] Projekt kompiliert fehlerfrei

---

## Erwartete Dateien/Änderungen

```
A  Packages/.../StateMachine/States/PlayerSlidingState.cs             (Neuer State)
M  Packages/.../StateMachine/PlayerMovementStateMachine.cs            (+SlidingState Property + Instanz)
```

---

**Nächster Schritt:** [21.5 Entry/Exit-Transitions](21.5-entry-exit-transitions.md)
