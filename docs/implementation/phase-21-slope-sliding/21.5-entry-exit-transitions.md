# 21.5 Entry/Exit-Transitions (Grounded, Falling)

> **Commit:** `feat(phase-21): 21.5 Slide Entry/Exit Transitions`
> **Branch:** `feat/slide-transitions`

---

## Ziel

Die bestehenden States (`PlayerGroundedState`, `PlayerFallingState`) um Transitionen zum/vom `PlayerSlidingState` erweitern.

---

## Anweisungen

### 1. PlayerGroundedState: Entry von Grounded → Sliding

**Datei:** `Packages/.../StateMachine/States/Grounded/PlayerGroundedState.cs`

In `OnUpdate()`, **vor** dem bestehenden Fall-Detection-Block, einen Slope-Check einfügen:

```csharp
protected override void OnUpdate()
{
    // NEU: Slope Sliding Check
    if (ShouldTransitionToSliding())
    {
        ChangeState(StateMachine.SlidingState);
        return;
    }

    // Bestehender Code: Fall-Detection, Edge-Handling, etc.
    ...
}

private bool ShouldTransitionToSliding()
{
    var groundInfo = Player.Locomotion.GroundInfo;

    // Slope muss steiler als MaxSlopeAngle sein
    if (groundInfo.SlopeAngle <= Config.MaxSlopeAngle)
        return false;

    // Motor muss noch Bodenkontakt haben (aber instabil)
    if (!Player.Locomotion.Motor.GroundingStatus.FoundAnyGround)
        return false;

    return true;
}
```

> **Reihenfolge wichtig:** Der Slope-Check muss VOR dem Fall-Check stehen, damit der Character nicht fälschlicherweise in den Falling-State wechselt, wenn er auf einer steilen aber mit Bodenkontakt-versehenen Surface steht.

### 2. PlayerFallingState: Landing auf steiler Slope

**Datei:** `Packages/.../StateMachine/States/Airborne/PlayerFallingState.cs`

In der Landing-Kategorisierung (wo SoftLand/HardLand entschieden wird) einen Slope-Check ergänzen:

```csharp
// Bestehende Landing-Logik:
// if (landingSpeed < Config.SoftLandingThreshold) → SoftLand
// else → HardLand

// NEU: Vor der Landing-Kategorisierung prüfen:
var groundInfo = Player.Locomotion.GroundInfo;
if (groundInfo.SlopeAngle > Config.MaxSlopeAngle
    && Player.Locomotion.Motor.GroundingStatus.FoundAnyGround)
{
    // Landing auf steiler Slope → direkt in Sliding
    ChangeState(StateMachine.SlidingState);
    return;
}

// Bestehende Soft/Hard Landing Logik...
```

> **WICHTIG:** Der Slope-Check muss vor der SoftLand/HardLand-Entscheidung stehen. Sonst würde der Character zuerst landen und dann erst rutschen — was visuell ruckeln würde.

### 3. PlayerJumpingState: Landing auf steiler Slope (falls nötig)

Prüfen ob `PlayerJumpingState` eine eigene Landing-Logik hat oder ob die Transition über `FallingState` läuft. Falls der JumpingState direkt landen kann (z.B. bei Rampen):

```csharp
// Gleicher Check wie in FallingState
if (groundInfo.SlopeAngle > Config.MaxSlopeAngle && FoundAnyGround)
{
    ChangeState(StateMachine.SlidingState);
    return;
}
```

### 4. Edge Cases absichern

**Problem:** Character steht am Rand einer steilen Slope und "flackert" zwischen Grounded und Sliding.

**Lösung:** Die `MinSlideTime` im SlidingState (bereits implementiert in 21.4) verhindert sofortiges Verlassen. Zusätzlich:

- In `PlayerGroundedState`: Erst Sliding triggern wenn SlopeAngle konsistent > MaxSlopeAngle ist (nicht bei einem einzelnen Frame)
- Optional: Einen `_steepSlopeFrameCount` Counter analog zu `_groundedFrameCount` in FallingState

```csharp
// Optional: Frame-basierter Guard
private int _steepSlopeFrameCount;

protected override void OnUpdate()
{
    if (groundInfo.SlopeAngle > Config.MaxSlopeAngle && FoundAnyGround)
    {
        _steepSlopeFrameCount++;
        if (_steepSlopeFrameCount >= 2) // 2 Frames konsistent
        {
            ChangeState(StateMachine.SlidingState);
            return;
        }
    }
    else
    {
        _steepSlopeFrameCount = 0;
    }

    // Rest der Logik...
}
```

### 5. Kompilierung prüfen

```bash
powershell -Command "Get-Content 'C:\Users\marcu\AppData\Local\Unity\Editor\Editor.log' -Tail 100 | Select-String -Pattern 'error|CS\d{4}'"
```

---

## Verifikation

- [ ] Grounded → Sliding Transition bei `SlopeAngle > MaxSlopeAngle`
- [ ] Falling → Sliding Transition bei Landing auf steiler Slope
- [ ] Slope-Check steht VOR Fall-Detection in GroundedState
- [ ] Slope-Check steht VOR SoftLand/HardLand in FallingState
- [ ] Kein Flackern am Grenzwinkel (MinSlideTime + optional Frame-Guard)
- [ ] Sliding → Idle/Moving Transition wenn Slope begehbar wird
- [ ] Sliding → Falling wenn Bodenkontakt verloren
- [ ] Projekt kompiliert fehlerfrei

---

## Erwartete Änderungen

```
M  Packages/.../StateMachine/States/Grounded/PlayerGroundedState.cs  (+Slope-Check in OnUpdate)
M  Packages/.../StateMachine/States/Airborne/PlayerFallingState.cs   (+Slope-Check in Landing)
M  Packages/.../StateMachine/States/Airborne/PlayerJumpingState.cs   (+Slope-Check, falls eigene Landing)
```

---

**Nächster Schritt:** [21.6 Animation-Integration](21.6-animation-integration.md)
