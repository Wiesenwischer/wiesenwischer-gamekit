# 21.3 Slide-Intent in CharacterLocomotion

> **Commit:** `feat(phase-21): 21.3 Slide-Intent + Physik`
> **Branch:** `feat/slide-locomotion-intent`

---

## Ziel

`CharacterLocomotion.IsSliding` aktivieren und die Slide-Velocity-Berechnung in `UpdateVelocity()` implementieren. Das Intent-System wird um `SetSliding()` erweitert — analog zu `RequestJump()`.

---

## Anweisungen

### 1. IsSliding implementieren

**Datei:** `Packages/.../Locomotion/CharacterLocomotion.cs`

Das bestehende `IsSliding` (aktuell `=> false`) durch eine richtige Implementierung ersetzen:

```csharp
private bool _isSliding;

/// <summary>
/// Ob der Character gerade auf einem steilen Hang rutscht.
/// Wird vom PlayerSlidingState gesetzt.
/// </summary>
public bool IsSliding => _isSliding;

/// <summary>
/// Setzt den Sliding-Zustand. Wird vom State aufgerufen (Enter/Exit).
/// </summary>
public void SetSliding(bool sliding)
{
    _isSliding = sliding;
}
```

### 2. UpdateVelocity um Slide-Branch erweitern

In `UpdateVelocity()` (oder der äquivalenten Methode) einen neuen Branch vor der normalen Horizontal-Berechnung einfügen:

```csharp
if (_isSliding)
{
    ApplySlideVelocity(ref currentVelocity, deltaTime);
}
else
{
    // Bestehende normale Horizontal-Velocity-Berechnung
    ...
}
```

### 3. ApplySlideVelocity implementieren

Neue private Methode in `CharacterLocomotion`:

```csharp
private void ApplySlideVelocity(ref Vector3 currentVelocity, float deltaTime)
{
    var groundNormal = _cachedGroundInfo.GroundNormal;
    float slopeAngle = _cachedGroundInfo.SlopeAngle;

    // Basis-Slide-Geschwindigkeit
    float slideSpeed = _config.SlopeSlideSpeed;

    if (_config.UseSlopeDependentSlideSpeed)
    {
        // SlopeModule.CalculateSlideVelocity() nutzen
        Vector3 slideVelocity = _slopeModule.CalculateSlideVelocity(
            groundNormal, slideSpeed, slopeAngle);
        slideSpeed = slideVelocity.magnitude;
    }

    // Rutsch-Richtung: Hangabwärts auf der Oberfläche
    Vector3 slideDirection = Vector3.ProjectOnPlane(Vector3.down, groundNormal).normalized;
    Vector3 targetSlideVelocity = slideDirection * slideSpeed;

    // Spieler-Lenkung (seitlich, reduziert)
    if (_config.SlideSteerStrength > 0f && _currentMoveInput.sqrMagnitude > 0.01f)
    {
        Vector3 steerDirection = GetCameraRelativeMoveDirection(_currentMoveInput);
        // Nur seitliche Komponente (quer zur Rutsch-Richtung)
        Vector3 lateral = Vector3.ProjectOnPlane(steerDirection, slideDirection);
        lateral = Vector3.ProjectOnPlane(lateral, groundNormal);

        if (lateral.sqrMagnitude > 0.001f)
        {
            targetSlideVelocity += lateral.normalized * slideSpeed * _config.SlideSteerStrength;
        }
    }

    // Sanftes Eingleiten (MoveTowards statt sofortiger Geschwindigkeit)
    Vector3 horizontalCurrent = new Vector3(currentVelocity.x, 0f, currentVelocity.z);
    Vector3 horizontalTarget = new Vector3(targetSlideVelocity.x, 0f, targetSlideVelocity.z);

    Vector3 newHorizontal = Vector3.MoveTowards(
        horizontalCurrent,
        horizontalTarget,
        _config.SlideAcceleration * deltaTime);

    currentVelocity.x = newHorizontal.x;
    currentVelocity.z = newHorizontal.z;

    // Vertikale Komponente: Gravity-Module übernimmt weiterhin
    // (Character hat Bodenkontakt, also GroundingVelocity)
}
```

### 4. Motor-Settings während Slide

In `UpdateVelocity()` oder via Motor-Konfiguration:

```csharp
if (_isSliding)
{
    // Keine Steps auf steilen Slopes
    Motor.StepHandling = StepHandlingMethod.None;
}
else
{
    // Normales Step-Handling wiederherstellen
    Motor.StepHandling = StepHandlingMethod.Standard;
}
```

> **Hinweis:** Falls der Motor die StepHandling-Eigenschaft nicht direkt exponiert, kann dies alternativ über einen Flag in der Config gesteuert werden. Bestehende `StepDetectionEnabled`-Logik in ReusableData prüfen.

### 5. GroundInfo Zugriff sicherstellen

Prüfen ob `_cachedGroundInfo.SlopeAngle` und `_cachedGroundInfo.GroundNormal` korrekt befüllt werden, wenn der Character auf einer unstabilen Surface steht (`!IsStableOnGround` aber `FoundAnyGround`).

Falls nötig: `PostGroundingUpdate()` erweitern, damit GroundInfo auch bei unstabilen Surfaces aktualisiert wird.

### 6. Kompilierung prüfen

```bash
powershell -Command "Get-Content 'C:\Users\marcu\AppData\Local\Unity\Editor\Editor.log' -Tail 100 | Select-String -Pattern 'error|CS\d{4}'"
```

---

## Verifikation

- [ ] `IsSliding` gibt `true` zurück wenn `SetSliding(true)` aufgerufen wurde
- [ ] `ApplySlideVelocity` berechnet korrekte Hangabwärts-Richtung
- [ ] Slide-Geschwindigkeit skaliert mit Steilheit (wenn `UseSlopeDependentSlideSpeed = true`)
- [ ] Spieler-Lenkung hat sichtbaren Effekt (seitliche Ablenkung)
- [ ] `SlideAcceleration` bewirkt sanftes Eingleiten
- [ ] Step-Handling ist während Sliding deaktiviert
- [ ] Projekt kompiliert fehlerfrei

---

## Erwartete Änderungen

```
M  Packages/.../Locomotion/CharacterLocomotion.cs     (+IsSliding, +SetSliding, +ApplySlideVelocity, UpdateVelocity Branch)
```

---

**Nächster Schritt:** [21.4 PlayerSlidingState](21.4-sliding-state.md)
