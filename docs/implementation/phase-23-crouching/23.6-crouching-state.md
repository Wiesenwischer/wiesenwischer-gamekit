# 23.6 PlayerCrouchingState implementieren

> **Commit:** `feat(phase-23): 23.6 PlayerCrouchingState`
> **Branch:** `feat/crouch-state`

---

## Ziel

Den `PlayerCrouchingState` implementieren — ein einzelner State der sowohl Crouch-Idle als auch Crouch-Moving handhabt.

---

## Anweisungen

### 1. PlayerCrouchingState erstellen

**Datei:** `Packages/Wiesenwischer.GameKit.CharacterController.Core/Runtime/Core/StateMachine/States/Grounded/PlayerCrouchingState.cs`

**Vererbung:** `PlayerCrouchingState : PlayerGroundedState`

### 2. Klassen-Struktur

```csharp
namespace Wiesenwischer.GameKit.CharacterController.StateMachine.States
{
    public class PlayerCrouchingState : PlayerGroundedState
    {
        public PlayerCrouchingState(PlayerMovementStateMachine stateMachine)
            : base(stateMachine) { }

        protected override void OnEnter()
        {
            base.OnEnter();

            // 1. Crouch-Status setzen
            ReusableData.IsCrouching = true;
            Player.Locomotion.SetCrouching(true);

            // 2. Animation starten
            Player.AnimationController?.PlayState(CharacterAnimationState.Crouch);
        }

        protected override void OnUpdate()
        {
            base.OnUpdate();

            // Speed basierend auf Movement-Input
            if (ReusableData.MoveInput.sqrMagnitude > 0.01f)
            {
                float crouchSpeedModifier = Config.CrouchSpeed / Config.WalkSpeed;
                ReusableData.MovementSpeedModifier = crouchSpeedModifier;
            }
            else
            {
                ReusableData.MovementSpeedModifier = 0f;
            }
        }

        protected override void OnHandleInput()
        {
            base.OnHandleInput(); // Grounded-Checks (Fall, Slope)

            // Toggle: C-Taste nochmal → Aufstehen
            if (ReusableData.CrouchTogglePressed && Player.Locomotion.CanStandUp())
            {
                ExitCrouch();
                return;
            }

            // Sprint beendet Crouch (wenn konfiguriert)
            if (Config.CanSprintFromCrouch && ReusableData.SprintHeld
                && Player.Locomotion.CanStandUp())
            {
                ExitCrouch();
                ChangeState(StateMachine.SprintingState);
                return;
            }

            // Jump aus Crouch (wenn konfiguriert)
            if (Config.CanJumpFromCrouch && ReusableData.JumpPressed)
            {
                ExitCrouch();
                // Jump-Transition wird vom Grounded-Base oder
                // dem Folge-State behandelt
                return;
            }
        }

        protected override void OnExit()
        {
            base.OnExit();
        }

        private void ExitCrouch()
        {
            ReusableData.IsCrouching = false;
            Player.Locomotion.SetCrouching(false);

            // Zum passenden Grounded-State wechseln
            if (ReusableData.MoveInput.sqrMagnitude > 0.01f)
            {
                if (ReusableData.ShouldWalk)
                    ChangeState(StateMachine.WalkingState);
                else
                    ChangeState(StateMachine.RunningState);
            }
            else
            {
                ChangeState(StateMachine.IdlingState);
            }
        }
    }
}
```

### 3. Wichtige Design-Entscheidungen

| Aspekt | Entscheidung | Begründung |
|--------|-------------|------------|
| Einzelner State | Idle + Moving in einem State | Speed-Parameter steuert Animation (Blend Tree) |
| Stand-Up-Check | `CanStandUp()` vor jedem Exit | Verhindert Aufstehen unter Decken |
| Sprint-Exit | Automatisch bei Sprint-Input | Spec: Sprint beendet Crouch |
| Jump-Exit | Aufstehen + Jump | Spec: CanJumpFromCrouch konfigurierbar |
| Falling-Exit | Via base.OnUpdate() | Grounded-Base erkennt Kante automatisch |

### 4. Hinweise

- **base.OnHandleInput():** Muss aufgerufen werden für Fall-Detection und Slope-Checks. Aber prüfe ob dort Jump-Handling stattfindet das mit Crouch-Jump kollidiert.
- **Falling/Sliding Exit:** Wenn der Character über eine Kante fällt oder auf einen steilen Hang gerät, muss `SetCrouching(false)` in `OnExit()` aufgerufen werden — prüfe ob der Base-Class `OnExit()` dafür ausreicht oder ob ein expliziter Call nötig ist.
- **OnExit() Safety:** `OnExit()` sollte immer `SetCrouching(false)` aufrufen, falls der State aus einem unerwarteten Grund verlassen wird (z.B. Falling).

---

## Verifikation

- [ ] `PlayerCrouchingState.cs` kompiliert
- [ ] Erbt von `PlayerGroundedState`
- [ ] `OnEnter()`: Setzt `IsCrouching = true`, startet Capsule-Transition
- [ ] `OnUpdate()`: Speed-Modifier basierend auf Movement-Input
- [ ] C-Taste → Exit Crouch (wenn CanStandUp)
- [ ] Sprint → Exit Crouch + Sprinting (wenn CanSprintFromCrouch)
- [ ] Jump → Exit Crouch + Jump (wenn CanJumpFromCrouch)
- [ ] Über Kante → Exit Crouch + Falling
- [ ] C-Taste unter Decke → Bleibt im Crouch
- [ ] `OnExit()`: Setzt `IsCrouching = false`, startet Capsule-Transition zurück

---

## Erwartete Dateien

```
Packages/.../Runtime/Core/StateMachine/States/Grounded/PlayerCrouchingState.cs   (NEU)
```

---

**Nächster Schritt:** [23.7 StateMachine + GroundedState Transition](23.7-statemachine-transition.md)
