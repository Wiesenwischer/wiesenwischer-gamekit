# 24.4 Unit Tests

> **Commit-Message:** `test(phase-24): 24.4 FootIK Terrain-Adaptive Tests`
> **Branch:** `test/footik-terrain-adaptive`
> **Spec-Referenz:** [FootIK Verbesserungen — Test-Plan](../../specs/FootIK_Verbesserungen_Spezifikation.md#unit-tests)

---

## Ziel

Unit Tests für alle drei Fixes erstellen. Die Tests validieren die mathematischen Berechnungen isoliert (ohne Unity Runtime/Animator), analog zu den bestehenden `FootIKTests.cs`.

---

## Testdatei

**Datei:** `Packages/Wiesenwischer.GameKit.CharacterController.IK/Tests/Runtime/FootIKTests.cs`

Die neuen Tests werden in die bestehende Testklasse `FootIKTests` eingefügt. Die Tests nutzen denselben Stil wie die vorhandenen Tests — direkte Berechnung der Formeln ohne MonoBehaviour-Instanziierung.

---

## Tests

### Fix 1: Body-Offset nach oben

```csharp
[Test]
public void BodyOffset_AllowsSmallUpward()
{
    // Positiver Offset soll NICHT auf 0 geclampt werden
    float maxFootAdjustment = 0.4f;
    float maxBodyUpOffset = 0.05f;
    float targetBodyOffset = 0.04f; // footOffset-Kompensation

    float clamped = Mathf.Clamp(targetBodyOffset, -maxFootAdjustment, maxBodyUpOffset);
    Assert.AreEqual(0.04f, clamped, 0.001f);
}

[Test]
public void BodyOffset_ClampsAtMaxUp()
{
    // Offset über maxBodyUpOffset wird geclampt
    float maxFootAdjustment = 0.4f;
    float maxBodyUpOffset = 0.05f;
    float targetBodyOffset = 0.1f; // Zu hoch

    float clamped = Mathf.Clamp(targetBodyOffset, -maxFootAdjustment, maxBodyUpOffset);
    Assert.AreEqual(0.05f, clamped, 0.001f);
}

[Test]
public void BodyOffset_StillAllowsDownward()
{
    // Negativer Offset funktioniert weiterhin (Regression)
    float maxFootAdjustment = 0.4f;
    float maxBodyUpOffset = 0.05f;
    float targetBodyOffset = -0.2f;

    float clamped = Mathf.Clamp(targetBodyOffset, -maxFootAdjustment, maxBodyUpOffset);
    Assert.AreEqual(-0.2f, clamped, 0.001f);
}
```

### Fix 2: Terrain-Varianz

```csharp
[Test]
public void TerrainVariance_FlatGround_ReturnsZero()
{
    // Gleiche Höhe + vertikale Normalen → Varianz = 0
    float leftY = 0f;
    float rightY = 0f;
    Vector3 leftNormal = Vector3.up;
    Vector3 rightNormal = Vector3.up;

    float heightDiff = Mathf.Abs(leftY - rightY);
    float leftNormalDev = 1f - Vector3.Dot(leftNormal, Vector3.up);
    float rightNormalDev = 1f - Vector3.Dot(rightNormal, Vector3.up);
    float normalDev = Mathf.Max(leftNormalDev, rightNormalDev);
    float variance = heightDiff + normalDev * 0.1f;

    Assert.AreEqual(0f, variance, 0.001f);
}

[Test]
public void TerrainVariance_UnevenGround_ReturnsPositive()
{
    // Verschiedene Höhen → Varianz > 0
    float leftY = 0f;
    float rightY = 0.1f; // 10cm Stufe
    Vector3 leftNormal = Vector3.up;
    Vector3 rightNormal = Vector3.up;

    float heightDiff = Mathf.Abs(leftY - rightY);
    float leftNormalDev = 1f - Vector3.Dot(leftNormal, Vector3.up);
    float rightNormalDev = 1f - Vector3.Dot(rightNormal, Vector3.up);
    float normalDev = Mathf.Max(leftNormalDev, rightNormalDev);
    float variance = heightDiff + normalDev * 0.1f;

    Assert.Greater(variance, 0f);
    Assert.AreEqual(0.1f, variance, 0.001f);
}

[Test]
public void TerrainVariance_Slope_IncludesNormalDeviation()
{
    // Schräge Normalen erhöhen Varianz auch bei gleicher Höhe
    float leftY = 0f;
    float rightY = 0f; // Gleiche Höhe
    Vector3 leftNormal = Vector3.up;
    Vector3 rightNormal = new Vector3(0f, 0.866f, 0.5f).normalized; // 30° Slope

    float heightDiff = Mathf.Abs(leftY - rightY);
    float leftNormalDev = 1f - Vector3.Dot(leftNormal, Vector3.up);
    float rightNormalDev = 1f - Vector3.Dot(rightNormal, Vector3.up);
    float normalDev = Mathf.Max(leftNormalDev, rightNormalDev);
    float variance = heightDiff + normalDev * 0.1f;

    Assert.Greater(variance, 0f);
    // normalDev ≈ 0.134 → variance ≈ 0.0134
    Assert.Greater(normalDev, 0.1f);
}

[Test]
public void TerrainWeight_BelowThreshold_Interpolates()
{
    float threshold = 0.03f;
    float variance = 0.015f; // Halb

    float terrainWeight = Mathf.InverseLerp(0f, threshold, variance);
    Assert.AreEqual(0.5f, terrainWeight, 0.001f);
}

[Test]
public void TerrainWeight_AboveThreshold_IsOne()
{
    float threshold = 0.03f;
    float variance = 0.1f; // Weit über Threshold

    float terrainWeight = Mathf.InverseLerp(0f, threshold, variance);
    Assert.AreEqual(1f, terrainWeight, 0.001f);
}
```

### Fix 3: Dead Zone

```csharp
[Test]
public void FootDeadZone_SmallDelta_ReducesWeight()
{
    // Delta < DeadZone → Weight < 1
    float deadZone = 0.02f;
    float delta = 0.01f; // 1cm, unter Dead Zone
    float effectiveWeight = 1f;

    float footWeight = effectiveWeight * Mathf.InverseLerp(0f, deadZone, delta);
    Assert.AreEqual(0.5f, footWeight, 0.001f);
}

[Test]
public void FootDeadZone_LargeDelta_FullWeight()
{
    // Delta > DeadZone → Weight = 1
    float deadZone = 0.02f;
    float delta = 0.05f; // 5cm, über Dead Zone
    float effectiveWeight = 1f;

    float footWeight = effectiveWeight * Mathf.InverseLerp(0f, deadZone, delta);
    Assert.AreEqual(1f, footWeight, 0.001f);
}

[Test]
public void FootDeadZone_ZeroDelta_ZeroWeight()
{
    // Delta = 0 → Weight = 0
    float deadZone = 0.02f;
    float delta = 0f;
    float effectiveWeight = 1f;

    float footWeight = effectiveWeight * Mathf.InverseLerp(0f, deadZone, delta);
    Assert.AreEqual(0f, footWeight, 0.001f);
}
```

---

## Bestehende Tests aktualisieren

Der bestehende Test `BodyOffset_NeverPositive` muss angepasst werden, da Body-Offset jetzt positiv sein darf:

```csharp
[Test]
public void BodyOffset_NeverPositive()  // UMBENENNEN zu:
public void BodyOffset_ClampsAtZeroWithoutUpOffset()
{
    // Bei maxBodyUpOffset = 0 ist Verhalten wie vorher
    float maxFootAdjustment = 0.4f;
    float maxBodyUpOffset = 0f;
    float leftDelta = 0.1f;
    float rightDelta = 0.05f;
    float offset = Mathf.Min(leftDelta, rightDelta);
    offset = Mathf.Clamp(offset, -maxFootAdjustment, maxBodyUpOffset);
    Assert.AreEqual(0f, offset, 0.001f);
}
```

---

## Verifikation

- [ ] Alle bestehenden Tests grün
- [ ] Alle neuen Tests grün
- [ ] Compiler-Fehler prüfen
- [ ] Test Runner in Unity zeigt alle Tests

---

## Erwartete Dateien

| Datei | Änderung |
|-------|----------|
| `FootIKTests.cs` | 10 neue Tests, 1 bestehender Test umbenannt/angepasst |

---

→ Nächster Schritt: [24.5 Play Mode Verifikation](24.5-play-mode-verifikation.md)
