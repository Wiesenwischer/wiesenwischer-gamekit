# 24.2 Terrain-Varianz-basierter IK-Weight

> **Commit-Message:** `fix(phase-24): 24.2 Terrain-Varianz IK-Weight`
> **Branch:** `fix/footik-terrain-variance`
> **Spec-Referenz:** [FootIK Verbesserungen — Fix 2](../../specs/FootIK_Verbesserungen_Spezifikation.md#fix-2-terrain-varianz-basierter-ik-weight)

---

## Ziel

Den IK-Weight proportional zur tatsächlichen Terrain-Unebenheit skalieren. Auf flachem Boden → Weight ~0 (Animation steuert), auf unebenem Terrain → Weight ~1 (IK steuert). Aktuell behandelt FootIK flachen Boden identisch zu Treppen/Slopes.

---

## Änderungen

### 1. Neuer Parameter `_terrainVarianceThreshold`

Neuer `[Header("Terrain Adaptation")]` Bereich nach dem "Locomotion Blend" Header:

```csharp
[Header("Terrain Adaptation")]
[Tooltip("Höhendifferenz (m) ab der IK voll aktiv wird.")]
[SerializeField] private float _terrainVarianceThreshold = 0.03f;
```

### 2. Neue private Felder

```csharp
// Terrain-Varianz
private float _terrainWeight = 1f;
private Vector3 _leftFootNormal;
private Vector3 _rightFootNormal;
```

### 3. CastFoot-Signatur erweitern

Die Methode `CastFoot` bekommt einen zusätzlichen `out Vector3 surfaceNormal` Parameter:

```csharp
private bool CastFoot(Vector3 footPos, out Vector3 targetPos, out Quaternion targetRot,
                       out Vector3 surfaceNormal)
{
    Vector3 origin = footPos + Vector3.up * _raycastHeight;
    float distance = _raycastHeight + _raycastDepth;

    if (Physics.Raycast(origin, Vector3.down, out RaycastHit hit, distance, _groundLayers))
    {
        targetPos = hit.point + hit.normal * _footOffset;
        targetRot = Quaternion.FromToRotation(Vector3.up, hit.normal)
                    * transform.rotation;
        surfaceNormal = hit.normal;  // NEU
        return true;
    }

    targetPos = footPos;
    targetRot = Quaternion.identity;
    surfaceNormal = Vector3.up;  // Default: flach
    return false;
}
```

### 4. CastFoot-Aufrufe in PrepareIK aktualisieren

```csharp
_leftFootHit = CastFoot(leftFoot, out _leftFootTarget, out _leftFootRotation, out _leftFootNormal);
_rightFootHit = CastFoot(rightFoot, out _rightFootTarget, out _rightFootRotation, out _rightFootNormal);
```

### 5. Terrain-Varianz berechnen (in PrepareIK, nach den Raycasts)

Nach den CastFoot-Aufrufen und **vor** der Body-Offset-Berechnung:

```csharp
// Terrain-Varianz berechnen
float terrainVariance = 0f;
if (_leftFootHit && _rightFootHit)
{
    // Höhendifferenz zwischen beiden Fuß-Targets
    float heightDiff = Mathf.Abs(_leftFootTarget.y - _rightFootTarget.y);

    // Normalen-Abweichung von der Vertikalen (0 = flach, 1 = senkrechte Wand)
    float leftNormalDev = 1f - Vector3.Dot(_leftFootNormal, Vector3.up);
    float rightNormalDev = 1f - Vector3.Dot(_rightFootNormal, Vector3.up);
    float normalDev = Mathf.Max(leftNormalDev, rightNormalDev);

    // Kombinierte Terrain-Varianz
    terrainVariance = heightDiff + normalDev * 0.1f;
}

// IK-Weight proportional zur Terrain-Varianz
_terrainWeight = Mathf.InverseLerp(0f, _terrainVarianceThreshold, terrainVariance);
```

**Erklärung der Formel:**
- `heightDiff`: Hauptkriterium — wie unterschiedlich stehen die Füße?
- `normalDev`: Sekundärkriterium — stehen die Füße auf einer schiefen Fläche? Gewichtet mit `0.1f`, damit Normalen-Abweichung nur bei deutlicher Neigung relevant wird.
- `InverseLerp`: Lineare Interpolation von 0→1 über den Threshold-Bereich. Bei `terrainVariance = 0` → `_terrainWeight = 0`, bei `terrainVariance >= threshold` → `_terrainWeight = 1`.

### 6. `_terrainWeight` in ProcessIK einrechnen

In `ProcessIK()`, die effectiveWeight-Berechnung erweitern:

```csharp
// VORHER:
float effectiveWeight = _weight * _locomotionBlendWeight;

// NACHHER:
float effectiveWeight = _weight * _locomotionBlendWeight * _terrainWeight;
```

---

## Erwartetes Verhalten

| Szenario | terrainVariance | _terrainWeight | effectiveWeight |
|----------|----------------|----------------|-----------------|
| Flacher Boden | ~0 | ~0 | ~0 (Animation steuert) |
| Treppe (10cm Stufe) | 0.1 | 1.0 | _weight (IK voll aktiv) |
| Leichte Slope (5°) | ~0.004 (Normal) | ~0.13 | Leichtes IK |
| Steile Slope (30°) | ~0.013 (Normal) | ~0.44 | Mittleres IK |
| Kante (ein Fuß 20cm tiefer) | 0.2 | 1.0 | _weight (IK voll aktiv) |

---

## Verifikation

- [ ] Compiler-Fehler prüfen
- [ ] Neuer Header "Terrain Adaptation" im Inspector sichtbar
- [ ] `_terrainVarianceThreshold` hat Default 0.03 im Inspector
- [ ] Auf flachem Boden: `_terrainWeight` → ~0 (Debug Log oder Inspector)
- [ ] Auf Treppe: `_terrainWeight` → ~1

---

## Erwartete Dateien

| Datei | Änderung |
|-------|----------|
| `FootIK.cs` | Neuer Parameter, neue Felder, CastFoot erweitert, Varianz-Berechnung, effectiveWeight angepasst |

---

→ Nächster Schritt: [24.3 Delta Dead Zone pro Fuß](24.3-dead-zone.md)
