# BDO-Style Combat -- Practical Unity Implementation Structure

This document provides a **practical Unity project structure** and class
layout based on the previously discussed AAA-style combat architecture.

Goal:

-   Clean separation of responsibilities
-   Avoid tight coupling
-   Enable future MMO networking
-   Prevent architecture refactors later

This structure assumes:

-   Custom CharacterMotor
-   Existing Character State Machine
-   BDO-style action combat design

------------------------------------------------------------------------

# 1. High-Level Architecture Overview

Core runtime flow:

INPUT ↓ CombatController (Brain) ├ ActionGraph ├ PhaseAuthority ├
DirectionalContext ├ CombatTags ├ PriorityCancel └ TargetingContext ↓
MotionAuthority ↓ CharacterMotor ↓ Animator (visual only) ↓ ImpactSystem

------------------------------------------------------------------------

# 2. Recommended Unity Folder Structure

Example:

Assets/ Combat/ Core/ CombatController.cs CombatContext.cs
CombatIntent.cs Graph/ ActionNode.cs ActionTransition.cs ActionGraph.cs
Phases/ AttackPhase.cs PhaseRuntime.cs Tags/ CombatTag.cs
CombatTagContainer.cs Motion/ MotionAuthority.cs MotionProfile.cs
Targeting/ TargetingSystem.cs TargetCandidate.cs Impact/ ImpactSystem.cs
ImpactEvent.cs HitStopSystem.cs Data/ AttackData.asset
MotionProfile.asset

    Character/
        Motor/
            CharacterMotor.cs
        StateMachine/
            CharacterStateMachine.cs

    Animation/
        AnimatorController

------------------------------------------------------------------------

# 3. Core Classes

## 3.1 CombatController

Main decision layer.

Responsibilities:

-   receive intents from input
-   manage current action node
-   evaluate transitions
-   manage phase progression
-   apply tags
-   coordinate motion authority

Pseudo structure:

class CombatController { ActionNode currentNode; PhaseRuntime
phaseRuntime; CombatTagContainer tags; }

------------------------------------------------------------------------

## 3.2 Action Graph

Defines combat logic structure.

ActionNode:

-   reference to AttackData
-   allowed transitions
-   motion profile
-   phase data

Transitions contain:

-   input requirements
-   tag requirements
-   priority rules
-   directional conditions

------------------------------------------------------------------------

## 3.3 Phase Authority

Manages attack timeline.

Example phases:

-   Startup
-   Active
-   Recovery

Responsibilities:

-   advance timer
-   trigger hit windows
-   allow cancel windows
-   activate motion profiles

------------------------------------------------------------------------

## 3.4 Motion Authority

Bridge between combat and movement.

Responsibilities:

-   read motion intent from combat
-   apply impulses to CharacterMotor
-   handle rotation assist

Important:

Animation should NOT drive movement directly.

------------------------------------------------------------------------

## 3.5 CharacterMotor

Independent system.

Responsibilities:

-   movement physics
-   collision resolution
-   velocity handling

Must NOT know about combat logic.

------------------------------------------------------------------------

## 3.6 Animator Layer

Responsibilities:

-   play animations
-   blend visuals

Animator must NOT contain gameplay logic.

------------------------------------------------------------------------

## 3.7 Impact System

Triggered when hit detected.

Pipeline:

ImpactEvent → listeners

Listeners may include:

-   HitStop
-   Camera effects
-   Audio
-   VFX
-   Reaction animations

------------------------------------------------------------------------

# 4. ScriptableObject Data Design

Recommended:

AttackData (ScriptableObject):

-   animation reference
-   phase durations
-   hit window timing
-   motion profile reference
-   cancel rules
-   tags applied

Benefits:

-   designer-friendly tuning
-   runtime iteration possible

------------------------------------------------------------------------

# 5. Update Flow Example

Input detected → create CombatIntent

CombatController.Update():

1.  Evaluate transitions from ActionGraph
2.  Update phase timer
3.  Apply phase logic
4.  Send motion intent to MotionAuthority
5.  Trigger animation state
6.  Handle hit detection if active phase

------------------------------------------------------------------------

# 6. Debugging Tools (Highly Recommended)

-   On-screen debug UI
-   Display:
    -   current node
    -   current phase
    -   active tags
    -   current target
    -   velocity

This dramatically speeds up iteration.

------------------------------------------------------------------------

# 7. Common Unity Mistakes to Avoid

❌ Putting combat logic inside Animator transitions.

❌ Using animation events as authoritative timing.

❌ Mixing CharacterMotor and combat logic.

❌ Hardcoding combos instead of using graph structure.

------------------------------------------------------------------------

# 8. Scalability Benefits

With this structure you can easily add:

-   new weapons
-   skills
-   networking validation
-   AI using same combat graph
-   data-driven balancing

------------------------------------------------------------------------

# Next Possible Topics

-   Enemy Reaction Model Architecture
-   MMO Networking Integration Strategy
-   Advanced Animation Layering Setup
