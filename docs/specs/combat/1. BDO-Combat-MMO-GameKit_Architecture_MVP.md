# BDO‑inspirierter Action‑Combat (MMO/GameKit) – Architektur & MVP‑Plan

> Kontext: Du willst dein Combat an **Black Desert Online (BDO)** anlehnen, startest mit **Sword & Shield** und fokussierst dich zunächst auf **Grundangriffe** (LMB/RMB).  
> Ziel: **Stabile, MMO‑taugliche Basis**, die sich *BDO‑artig* anfühlt, ohne später alles neu zu schreiben.

---

## 1. Was sich „BDO‑Feeling“ wirklich anfühlt (und warum)

Viele denken bei BDO an „schnelle Animationen + Effekte + Combos“. Das ist aber nicht das Fundament.

Das Fundament ist:

1. **Animation bestimmt Timing (Hit‑Windows, Combo‑Fenster, Recovery)** – nicht dein Input.
2. **Input Buffering** (Eingaben werden vorgemerkt) – dadurch wirkt alles „smooth“.
3. **Movement ist *animation-guided*, aber *motor-driven*** – dadurch bleibt es MMO‑tauglich.

Das bedeutet: Die Animation ist **Autorität fürs *Wann*** (z. B. wann trifft die Klinge), aber der Motor ist Autorität fürs **Wo** (Position/Bewegung), damit Prediction/Netcode/Physik nicht explodieren.

---

## 2. Root Motion vs. Animation‑Guided Movement (wichtigster Klärungspunkt)

### 2.1 Root‑Motion‑Driven (was du für MMO i. d. R. NICHT willst)
**Definition:** Die Animation bewegt das Character‑Transform direkt (Root Motion als Quelle der Wahrheit).

**Typische Nachteile (MMO/Netcode):**
- schwierige/instabile **Prediction**
- Desync‑Risiko (Client/Server bewegen sich unterschiedlich)
- Kollisions- und Physik‑Konflikte
- weniger deterministisches Verhalten

### 2.2 Animation‑Guided, Motor‑Driven (was BDO‑artig wirkt und MMO‑tauglich ist)
**Definition:** Die Animation „suggeriert“ Bewegung (Impulse/Rotation), aber der **CharacterMotor** setzt die finale Bewegung um.

**Merksatz:**
- Animation darf **Movement vorschlagen**
- Animation darf **nicht Transform setzen**

**Warum BDO trotzdem wie Root Motion wirkt:**
- sehr enge Synchronisation zwischen
  - Attack‑Phasen (Startup/Active/Recovery)
  - kleinen Vorwärtsimpulsen
  - Rotation Assist
  - Hitstop/Hit‑Reaction

Optionaler AAA‑Trick (später): **Root Motion Extraction**
- Animation hat Root Motion
- du liest Deltas aus und gibst sie dem Motor als „Movement‑Intent“
- Ergebnis: Root‑Motion‑Feel bei Motor‑Kontrolle (MMO‑freundlicher)

---

## 3. Die häufigste BDO‑Copy‑Falle: „Animator = Combat Brain“

### 3.1 Falscher Ansatz (führt zu Spaghetti)
> „Animator State Machine entscheidet die Combat‑Logik.“

Das endet in:
- unüberschaubaren Transitions
- schwer erweiterbaren Combos
- Cancel‑Fenstern, die überall verteilt sind
- Networking‑Schmerzen

### 3.2 Richtiger Ansatz (BDO‑tauglich)
> „CombatController entscheidet, Animator visualisiert.“

**Layering (saubere Kette):**
```
INPUT
  ↓
CombatController (Brain)
  ↓
CharacterStateMachine (Body condition)
  ↓
Animation Layer (Visualisierung)
  ↓
CharacterMotor (finale Bewegung)
```

---

## 4. Trennung: Character State vs. Combat State (entscheidend)

### 4.1 Character State Machine („Körperzustand“)
Beschreibt **was** der Charakter gerade ist:
- Idle
- Moving
- Attacking
- Stunned
- KnockedDown
- etc.

Diese States sind *Gameplay-/Control‑relevant*.

### 4.2 Combat State („wo in der Attack bist du“)
Beschreibt **welche Attack‑Phase/Chain‑Stufe** läuft:
- LightStep1 / LightStep2 / LightStep3
- HeavyAttack
- Recovery
- etc.

**Warum trennen?**
- Mehr Waffen später (Spear, Dual, Greatsword) ohne Code‑Rewrite
- Skill‑Cancels & Directionals ohne Transitions‑Explosion
- Networking/Prediction bleibt stabiler
- Combat bleibt data‑driven

---

## 5. MVP‑Umfang für Sword & Shield (sehr sinnvoll als Start)

### 5.1 Input Mapping (MVP)
- **LMB** = Light Attack Chain (3 Schritte)
- **RMB** = Heavy Attack (single)

### 5.2 Minimal benötigte Character States
- IdleState
- MoveState
- AttackingState (oder AttackLight/AttackHeavy als Unterzustände)
- AttackRecoverState (optional, kann auch Teil der Attack Timeline sein)

> Hinweis: Du brauchst **keinen „ComboState“** als monolithischen State. Combos gehören in die Combat‑Logik.

---

## 6. Attack als Timeline: Startup / Active / Recovery / Combo Window

Eine Attack ist kein „Instant Event“, sondern ein **Timing‑Ablauf**:

- **Startup** (noch kein Treffer)
- **Active / Hit Window** (Hitbox aktiv → Damage möglich)
- **Recovery** (Nachlauf)
- **Combo Window** (Zeitfenster, um die nächste Attack sauber zu chainen)

**Wichtig: Damage passiert nur im Hit Window.**  
Nicht beim Input. Nicht beim Start der Animation.

---

## 7. Input Buffering (BDO‑Feeling entsteht hier)

### 7.1 Idee
Wenn der Spieler während einer laufenden Attack klickt:
- Input wird **gepuffert** (queued)
- sobald das **Combo Window** offen ist, wird die nächste Attack gestartet

### 7.2 Warum das wichtig ist
Ohne Buffering fühlt sich Combat „sticky“ an:
- du musst „perfekt“ timen
- Inputs „gehen verloren“
- dein Combat wirkt unresponsiv

---

## 8. Data‑Driven Attack Definition (damit du später nicht refactorst)

Statt harter If‑Else‑Logik pro Stufe:

**AttackData** (z. B. ScriptableObject) enthält:
- AnimationClip / Animator Trigger
- hitStart / hitEnd (Timing)
- comboWindowStart / comboWindowEnd
- forwardImpulse
- rotationAssistStrength (optional)
- staminaCost (optional)
- tags (z. B. „light“, „heavy“, „shield“)

**Begründung:**
- neue Waffen/Attacks = neue Daten, kaum Code
- Balancing wird einfacher
- Networking/Replay‑Szenarien profitieren von deterministischen Daten

---

## 9. Movement Integration: „Impulse statt Root Motion“

AttackData liefert z. B.:
- **forwardImpulse = 2.5** (kleiner Step)
- optional: **impulseCurve** (später)

**Prinzip:**
- Animation Event / Combat Timing ruft im passenden Frame:
  - `motor.AddImpulse(forward * value)`
- der Motor setzt *final* die Position um

**Begründung (MMO):**
- Position bleibt kontrolliert/deterministisch
- Kollisionen/Prediction sind beherrschbar
- du kannst server‑autoritative Korrekturen sauberer machen

---

## 10. Hit Detection: robust und später serverfähig

### 10.1 Nicht empfohlen (für sauberes Timing)
- permanent aktiver Waffencollider + OnTriggerEnter
  - trifft oft „zu früh/zu spät“
  - kann mehrfach hitten (multi-hit bugs)

### 10.2 Empfohlen (MVP)
Nur während Hit Window:
- `Physics.OverlapCapsule` / `OverlapSphere` / „weapon sweep“
- Ergebnisse deduplizieren (pro Ziel nur einmal pro Hit Window)

**Begründung:**
- Treffer sind zeitlich exakt steuerbar
- weniger Bugs
- leichter zu replizieren/validieren serverseitig

---

## 11. „Feel“ – die 70% die man sofort einbauen sollte

Diese Dinge machen Combat sofort „teurer“ vom Feeling, ohne die Architektur zu sprengen:

1. **Forward Impulse** (kleiner Vorwärtsstep bei Hits/Swings)
2. **Rotation Assist** (sanft zum Ziel drehen, nicht snap)
3. **Hit Stop** (0.03–0.06s Minifreeze beim Treffer)
4. **Enemy Hit Reaction** (ohne Reaction wirkt alles wie „Luft“)
5. optional: **micro camera shake** (sehr subtil)

---

## 12. Konkreter MVP‑Plan (Checkliste)

### 12.1 Implementiere jetzt (Minimum)
- Light chain: L1 → L2 → L3
- Heavy: H1
- AttackData (Timing + Impulse)
- CombatController:
  - Input Buffer
  - Attack Timeline
  - Hit Window Activation
- Hit Detection während Hit Window
- einfache Hit Reaction am Gegner (z. B. small stagger)

### 12.2 Lass bewusst später (sonst verzettelst du dich)
- Cancels (i‑frames, dodge cancel, block cancel)
- Directional attacks / stance system
- Lock‑on vs free aim system
- Super Armor / Frontal Guard / Grab interactions
- komplexe CC‑Ketten (KD/Float/Bound)

**Begründung:** Erst muss das Grundgerüst stabil, deterministisch und erweiterbar sein.

---

## 13. Kurz‑FAQ: Passt das zu deinem kinematic Controller?

Ja. Genau dafür ist es gedacht.

- **Kinematic CharacterMotor** ist die korrekte Wahl für MMO‑taugliches Action Combat.
- Das „BDO‑Gefühl“ kommt nicht aus Transform‑Root Motion, sondern aus:
  - Attack‑Timeline
  - Buffering
  - Impuls/Rotation Assist
  - Hitstop + Reactions

---

## 14. Nächster Schritt (Reminder)

✅ **Erinnerung:** Als nächstes wollten wir über den **Action Graph** sprechen  
(= warum BDO nicht einfach „Combo Chains“ ist, sondern ein Graph aus Zuständen + Fenstern + Bedingungen – und wie du das so designst, dass du später Skills, Cancels und Weapons sauber hinzufügen kannst).
